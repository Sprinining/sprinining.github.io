---
title: Java内存模型（JMM）
date: 2024-07-18 11:04:26 +0800
categories: [java, concurrent programming]
tags: [Java, Concurrent Programming, JMM]
description: 
---
## Java 内存模型

------

`Java 内存模型（Java Memory Model，JMM）`定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则。它主要涉及到多线程环境下的共享变量可见性、指令重排等问题，是理解并发编程中的关键概念。

两种并发模型：

|                  | 如何通信                                                           | 如何同步                                                           |
| ---------------- | ------------------------------------------------------------------ | ------------------------------------------------------------------ |
| 消息传递并发模型 | 线程之间没有公共状态，线程间的通信必须通过发送消息来显示的进行通信 | 发送消息天然同步，因为发送消息总是在接受消息之前，因此同步时隐式的 |
| 共享内存并发模型 | 线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信  | 必须显式指定某段代码需要在线程之间互斥执行，同步是显式的           |

**Java 使用的是共享内存并发模型**。

### 共享变量

![jmm-0b9e4b1e-90e2-41bb-be89-f65e3a10fa08](/assets/media/pictures/java/Java内存模型（JMM）.assets/jmm-0b9e4b1e-90e2-41bb-be89-f65e3a10fa08.png)

对于每一个线程来说，栈都是私有的，而堆是共有的。在栈中的变量（局部变量、方法定义的参数、异常处理的参数）不会在线程之间共享，也就不会有内存可见性的问题，也不受内存模型的影响。而在堆中的变量是共享的，一般称之为共享变量。内存可见性针对的是堆中的共享变量。

### 内存可见性问题如何产生的

因为现代计算机为了高效，往往会在==高速缓存区==中缓存共享变量，因为 CPU 访问缓存区比访问内存要快得多。

> 线程之间的共享变量存在于主存中，每个线程都有一个私有的本地内存，存储了该线程的读、写共享变量的副本。本地内存是 Java 内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。

Java 线程之间的通信由 `Java 内存模型（JMM）`控制，从抽象的角度来说，JMM 定义了线程和主存之间的抽象关系。JMM 的抽象示意图如图所示：

![jmm-f02219aa-e762-4df0-ac08-6f4cceb535c2](/assets/media/pictures/java/Java内存模型（JMM）.assets/jmm-f02219aa-e762-4df0-ac08-6f4cceb535c2.jpg)

1. 所有的共享变量都存在主存中。
2. 每个线程都保存了一份该线程使用到的共享变量的副本。
3. 如果线程 A 与线程 B 之间要通信的话，必须经历下面 2 个步骤： 
   1. 线程 A 将本地内存 A 中更新过的共享变量刷新到主存中去。
   2. 线程 B 到主存中去读取线程 A 之前已经更新过的共享变量。

所以，线程 A 无法直接访问线程 B 的工作内存，线程间通信必须经过主存。

根据 JMM 的规定，**线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主存中读取**。

### 如何保证内存可见性

JMM 通过控制主存与每个线程的本地内存之间的交互，来提供内存可见性保证。

Java 中的 `volatile` 关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，`synchronized` 关键字不仅保证可见性，同时也保证了原子性（互斥性）。

在更底层，JMM 通过内存屏障来实现内存的可见性以及禁止重排序。为了程序员更方便地理解，设计者提出了 happens-before  的概念，

### JMM 与 Java 运行时内存区域的区别

**区别**：两者是不同的概念。JMM 是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开。而 Java 运行时内存的划分是具体的，是 JVM 运行 Java 程序时必要的内存划分。

**联系**：都存在私有数据区域和共享数据区域。一般来说，JMM 中的主存属于共享数据区域，包含了堆和方法区；同样，JMM 中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。

`Java 运行时内存区域`描述的是在 JVM 运行时，如何将内存划分为不同的区域，并且每个区域的功能和工作机制。主要包括以下几个部分：

- `方法区`：存储了每一个类的结构信息，如运行时常量池、字段和方法数据、构造方法和普通方法的字节码内容。
- `堆`：几乎所有的对象实例以及数组都在这里分配内存。这是 Java 内存管理的主要区域。
- `栈`：每一个线程有一个私有的栈，每一次方法调用都会创建一个新的栈帧，用于存储局部变量、操作数栈、动态链接、方法出口等信息。所有的栈帧都是在方法调用和方法执行完成之后创建和销毁的。
- `本地方法栈`：与栈类似，不过本地方法栈为 JVM 使用到的 native 方法

服务。

- `程序计数器`：每个线程都有一个独立的程序计数器，用于指示当前线程执行到了字节码的哪一行。

`Java 内存模型 (JMM)` 主要针对的是多线程环境下，如何在主内存与工作内存之间安全地执行操作。

它涵盖的主题包括变量的可见性、指令重排、原子操作等，旨在解决由于多线程并发编程带来的一些问题。

- `可见性`：当一个线程修改了共享变量的值，这个新值对于其他线程来说可以立即知道。
- `原子性`：一个或多个操作在整个过程中，不会被其他的线程或者操作所打断，这些操作是一个整体，要么都执行，要么都不执行。
- `有序性`：程序执行的顺序按照代码的先后顺序执行的。

## JMM 与重排序

------

指令重排一般分为以下三种：

- **编译器优化重排**，编译器在**不改变单线程程序语义**的前提下，重新安排语句的执行顺序。
- **指令并行重排**，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果**不存在数据依赖性**(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。
- **内存系统重排**，由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。

**指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致**。所以在多线程下，指令重排序可能会导致一些问题。

## JMM 与顺序一致性模型

------

当程序未正确同步的时候，就可能存在数据竞争，那么运行的结果往往充满了不确定性

>数据竞争：在一个线程中写一个变量，在另一个线程读同一个变量，并且写和读没有通过同步来排序。

Java 内存模型（JMM）对于正确同步多线程程序的内存一致性做了以下保证：**如果程序是正确同步的，程序的执行将具有顺序一致性**。即程序的执行结果和该程序在顺序一致性模型中执行的结果相同。

这里的同步包括使用 `volatile`、 `final`、 `synchronized `等关键字实现的同步。

### 什么是顺序一致性模型

顺序一致性模型是一个**理想化的理论参考模型**，它为程序提供了极强的内存可见性保证。顺序一致性模型有两大特性：

- 一个线程中的所有操作必须按照程序的顺序（即 Java 代码的顺序）来执行。
- 不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是**原子性的，且立刻对所有线程可见**。

假设有两个线程 A 和 B 并发执行，线程 A 有 3 个操作，他们在程序中的顺序是 A1->A2->A3，线程 B 也有 3 个操作，B1->B2->B3。

假设**正确使用了同步**，A 线程的 3 个操作执行后释放锁，B 线程获取同一个锁。那么在**顺序一致性模型**中的执行效果如下所示：

![jmm-9ce5973e-6100-41e6-96b8-29ddb738e7f8](/assets/media/pictures/java/Java内存模型（JMM）.assets/jmm-9ce5973e-6100-41e6-96b8-29ddb738e7f8.png)

操作的执行整体上有序，并且两个线程都只能看到这个执行顺序。

### JMM 为什么不保证顺序一致性

假设**没有使用同步**，那么在**顺序一致性模型**中的执行效果如下所示：

![jmm-6357c025-a6e0-4c89-939d-040e549fac12](/assets/media/pictures/java/Java内存模型（JMM）.assets/jmm-6357c025-a6e0-4c89-939d-040e549fac12.png)

操作的执行整体上无序，但是两个线程都只能看到这个执行顺序。之所以可以得到这个保证，是因为顺序一致性模型中的**每个操作必须立即对任意线程可见**。

**但是 JMM 没有这样的保证。**

比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，这个写操作根本没有被当前线程所执行。

只有当前线程把本地内存中写过的数据刷新到主存之后，这个写操作才对其他线程可见。在这种情况下，当前线程和其他线程看到的执行顺序是不一样的。

在顺序一致性模型中，所有操作完全按照程序的顺序串行执行。但是 JMM 中，临界区内（同步块或同步方法中）的代码可以发生重排序（但不允许临界区内的代码“逃逸”到临界区之外，因为会破坏锁的内存语义）。

虽然线程 A 在临界区做了重排序，但是因为锁的特性，线程 B 无法观察到线程 A 在临界区的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。

同时，JMM 会在退出临界区和进入临界区做特殊的处理，使得在临界区内程序获得与顺序一致性模型相同的内存视图。

**由此可见，JMM 的具体实现方针是：在不改变（正确同步的）程序执行结果的前提下，尽量为编译期和处理器的优化打开方便之门**。

对于未同步的多线程，JMM 只提供**最小安全性**：线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。

为了实现这个安全性，JVM 在堆上分配对象时，首先会对内存空间清零，然后才会在上面分配对象（这两个操作是同步的）。

**JMM 没有保证未同步程序的执行结果与该程序在顺序一致性中执行结果一致。因为如果要保证执行结果一致，那么 JMM 需要禁止大量的优化，对程序的执行性能会产生很大的影响。**

未同步程序在 JMM 和顺序一致性内存模型中的执行特性有如下差异：

1. 顺序一致性保证单线程内的操作会按程序的顺序执行；JMM 不保证单线程内的操作会按程序的顺序执行。（因为重排序，但是 JMM 保证单线程下的重排序不影响执行结果）
2. 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。（因为 JMM 不保证所有操作立即可见）
3. 顺序一致性模型保证对所有的内存读写操作都具有原子性，而 JMM 不保证对 64 位的 long 型和 double 型变量的写操作具有原子性。

## JMM 与 happens-before

------

对编译器和处理器来说，**只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。**

对于我们开发者来说，JMM 提供了 `happens-before` 规则（JSR-133 规范），满足了我们的诉求——**简单易懂，并且提供了足够强的内存可见性保证。**

JMM 使用 happens-before 的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程内，也可以是不同的线程种。

happens-before 关系的定义如下：

1. 如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
2. **两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before  关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。**

happens-before 关系本质上和 as-if-serial 语义是一回事。

as-if-serial 语义保证单线程内重排序后的执行结果和程序代码本身应有的结果是一致的，happens-before 关系保证正确同步的多线程程序的执行结果不被重排序改变。

总之，**如果操作 A happens-before 操作 B，那么操作 A 在内存上所做的操作对操作 B 都是可见的，不管它们在不在一个线程。**

### happens-before 关系有哪些

在 Java 中，有以下天然的 happens-before 关系：

- 程序顺序规则：一个线程中的每一个操作，happens-before 于该线程中的任意后续操作。
- 监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。
- volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。
- 传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。
- start 规则：如果线程 A 执行操作 `ThreadB.start()`启动线程 B，那么 A 线程的 `ThreadB.start()`操作 happens-before 于线程 B 中的任意操作。
- join 规则：如果线程 A 执行操作 `ThreadB.join()`并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 `ThreadB.join()`操作成功返回。

