---
title: 服务器搭建博客
date: 2025-06-02 22:34:39 +0800
categories: [other, blog]
tags: [Blog, Chripy, Docker, CICD]
description: ""
---
## 服务器搭建博客

操作系统： 

- Ubuntu 24.04 Server

最终目标：

- 博客基于 **Chirpy（Jekyll）**
- 使用 **Docker + Docker Compose** 在 Ubuntu 服务器上部署
- 使用 **GitHub Actions 实现 CI/CD**：每次提交博客代码，GitHub 自动构建并上传到服务器部署
- 博客以 **静态站点形式运行**，由 Nginx 提供服务

### 替换 apt 镜像

#### 给 Ubuntu 24.04 Server 版换国内镜像（阿里云示例）

1. 备份原有的 `sources.list`

```bash
sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
```

2. 替换为阿里云源

```bash
sudo nano /etc/apt/sources.list
```

清空内容，粘贴以下内容（针对 Ubuntu 24.04 `noble`）：

```bash
deb http://mirrors.aliyun.com/ubuntu/ noble main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ noble-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ noble-backports main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ noble-security main restricted universe multiverse
```

然后 `Ctrl+O` 保存，`Enter` 确认，`Ctrl+X` 退出。

3. 更新软件包索引

```bash
sudo apt update
```

如果看到类似：

```bash
Get:1 http://mirrors.aliyun.com/ubuntu noble InRelease [some KB]
...
```

说明镜像源生效，国内加速成功

#### 清华源 / 中科大源

清华源（TUNA）：

```txt
https://mirrors.tuna.tsinghua.edu.cn/ubuntu/
```

中科大（USTC）：

```txt
https://mirrors.ustc.edu.cn/ubuntu/
```

> 用法和上面一样，只需把 `mirrors.aliyun.com` 换成对应的域名。

关于 `# Ubuntu sources have moved to /etc/apt/sources.list.d/ubuntu.sources`

这是 Ubuntu 22.10 之后新增的一种 **`deb822` 格式源管理机制**，但：

- 它 **不会禁用你自己写在 `/etc/apt/sources.list` 里的源**；
- 两者是 **并行** 的，系统会同时读取 `/etc/apt/sources.list` 和 `/etc/apt/sources.list.d/*.sources`；
- 如果你手动设置了 `/etc/apt/sources.list`，就优先按你写的来（不会冲突）；
- 如果你希望清爽一点，也可以把 `/etc/apt/sources.list.d/ubuntu.sources` 文件**注释掉或删掉**，不过没必要。

### 安装 Docker

#### 设置 Docker 的 apt repository

```bash
# 更新系统软件包索引
sudo apt-get update

# 安装所需依赖（用于添加 HTTPS 认证源）
sudo apt-get install ca-certificates curl

# 创建 apt key 存放目录（如果已经存在不会报错）
sudo install -m 0755 -d /etc/apt/keyrings

# 下载 Docker 官方的 GPG 公钥，并保存为 docker.asc（用于验证软件源的合法性）
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc

# 设置 docker.asc 文件权限为所有用户可读（必须，否则 apt 会拒绝使用）
sudo chmod a+r /etc/apt/keyrings/docker.asc

# 添加 Docker 官方软件源到 APT 配置中
# 使用的是当前系统的版本代号（如 noble、jammy 等）
# 使用刚刚下载的 docker.asc 文件做签名验证
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "${UBUNTU_CODENAME:-$VERSION_CODENAME}") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# 再次更新软件包索引，使新的 Docker 源生效
sudo apt-get update
```

#### 安装 Docker 相关软件包

```bash
sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
```

#### 验证 Docker 安装

```bash
docker version
```

如果输出包含 Client 和 Server 字段，说明安装成功。

#### 替换 Docker 镜像

创建或编辑 Docker 配置文件：

```bash
sudo mkdir -p /etc/docker
sudo nano /etc/docker/daemon.json
```

把以下内容复制进去（包含多个国内镜像加速器）

```json
{
  "registry-mirrors": [
    "https://registry.docker-cn.com",
    "https://docker.mirrors.ustc.edu.cn",
    "https://hub-mirror.c.163.com",
    "https://mirror.baidubce.com"
  ]
}
```

按 `Ctrl + O` 保存，`Ctrl + X` 退出编辑器。

重启 Docker 服务使配置生效：

```bash
sudo systemctl daemon-reexec
sudo systemctl restart docker
```

验证配置是否生效：

```bash
docker info | grep -A 5 'Registry Mirrors'
```

输出应包含刚才配置的地址。

####  测试网络连通性

可以用 `curl` 测试网络连通性：

```bash
# 命令没响应，说明服务器无法直接访问 Docker Hub 的官方注册中心，这是导致拉不到官方镜像的根本原因
curl -I https://registry-1.docker.io/v2/

# 返回 HTTP 401 是正常的，说明：
# 服务器能访问阿里云镜像仓库的网络是通的；
# 401 是“未认证”，仓库要求认证（这属于正常安全流程），说明网络没问题。
curl -I https://registry.cn-hangzhou.aliyuncs.com/v2/
```

### 部署博客

本地项目目录应如下：

```css
your-blog/
├── _config.yml
├── Gemfile
├── Gemfile.lock
├── Dockerfile
├── docker-compose.yml
├── .github/
│   └── workflows/
│       └── deploy.yml       ← GitHub Actions 部署脚本
├── _posts/
├── _pages/
├── _site/                   ← 构建后自动生成
└── 其他 Jekyll 所需文件...
```

#### 手动下载镜像

##### 本地执行

第一步：预先拉取官方镜像（一次性）

```bash
docker pull jekyll/jekyll
docker pull nginx:alpine
```

第二步：保存镜像为压缩文件（建议 gzip）

```bash
docker save jekyll/jekyll | gzip > jekyll-jekyll.tar.gz
docker save nginx:alpine | gzip > nginx-alpine.tar.gz
```

第三步：将打包镜像上传到服务器

可以使用FileZilla

##### 服务器上操作

第一步：解压并导入镜像

```bash
gunzip -c jekyll-jekyll.tar.gz | docker load
gunzip -c nginx-alpine.tar.gz | docker load
```

可以用 `docker images` 确认是否导入成功：

```bash
REPOSITORY       TAG        IMAGE ID       ...
jekyll/jekyll    latest     ...
nginx            alpine     ...
```

 第二步：运行或构建容器

现在可以使用这些已存在的镜像直接运行之后配置的 `docker-compose.yml` 或 `docker run` 命令，Docker 不会去拉取远程镜像。

比如：

```bash
docker-compose up -d --build
```

或者直接构建新的镜像：

```bash
docker build -t chirpy-blog .
```

#### Dockerfile（多阶段构建）

```dockerfile
# 第一步：用官方 Jekyll 镜像构建 Chirpy 静态站点
FROM jekyll/jekyll:latest as builder

# 设置容器内的工作目录为 /site，后续命令都会在该目录下执行
WORKDIR /site

# 复制所有博客源文件（包括 Gemfile 等）
# 第一个.：指的是 Docker 构建上下文（build context） 中的当前目录（执行 docker build 时所在的本地目录）。
# 第二个.：指的是容器内部当前工作目录（也就是 WORKDIR 指定的目录，比如 /site）。
COPY . .

# 安装依赖（从 Gemfile）并构建网站到 _site/
RUN bundle install
RUN JEKYLL_ENV=production bundle exec jekyll build

# 第二步：用 nginx 运行构建好的静态站点
FROM nginx:alpine

# 将构建好的 _site 内容复制到 nginx 的根目录
COPY --from=builder /site/_site /usr/share/nginx/html

# 暴露 80 端口
EXPOSE 80

# 默认启动 nginx 前台服务
CMD ["nginx", "-g", "daemon off;"]
```

> Dockerfile 是什么？
>
> - Dockerfile 是一个文本文件，里面写着如何**一步步构建一个镜像**的“配方”。
> - 它告诉 Docker 怎么安装环境、复制代码、运行命令，最后生成一个**镜像**。
> - 简单说，Dockerfile 是用来**定义镜像的内容和行为**。

#### docker-compose.yml

```yaml
version: "3.8"

services:
  blog:
    build: .                  # 构建当前目录的 Dockerfile
    container_name: chirpy_blog
    ports:
      - "80:80"               # 映射服务器 80 端口
    restart: unless-stopped   # 自动重启
```

部署命令：

```bash
docker-compose up --build -d
```

> docker-compose.yml 是什么？
>
> - `docker-compose.yml` 是一个配置文件，用来**定义和管理多个容器（服务）**如何一起运行。
> - 它描述了容器之间的网络、数据卷挂载、端口映射、环境变量、依赖关系等。
> - 用 `docker-compose up` 命令可以一键启动整个应用的多个容器，方便管理。
>
> 它们的关系？
>
> - `docker-compose.yml` 里可以指定用哪个 Dockerfile 来构建镜像（或者直接用已有镜像）。
> - 也就是说，Dockerfile 负责**“造”镜像**，docker-compose.yml 负责**“用”镜像启动容器**。
> - 如果你的应用只有一个容器，也可以不用 docker-compose，但当涉及多个容器（比如 Chirpy 站点的构建容器 + nginx 容器）时，docker-compose 非常方便。

#### GitHub Secrets 设置

进入 GitHub 仓库 -> Settings -> Secrets and variables -> Actions，添加以下 Secret：

| Name       | 用途说明                  |
| ---------- | ------------------------- |
| `SSH_HOST` | 服务器 IP 或域名          |
| `SSH_USER` | 登录用户名（如 `ubuntu`） |
| `SSH_KEY`  | 私钥内容（用于 SSH 登录） |

SSH 私钥建议使用没有密码的单独部署密钥（用 `ssh-keygen` 创建）

#### GitHub Actions：`.github/workflows/deploy.yml`

```yaml
name: Build and Deploy Chirpy Blog

on:
  push:
    branches: [main]  # 监听 main 分支的提交

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: 拉取代码
      uses: actions/checkout@v4

    - name: 安装 Ruby 环境
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: 3.1

    - name: 安装依赖
      run: |
        gem install bundler
        bundle install

    - name: 构建 Chirpy 静态站点
      run: JEKYLL_ENV=production bundle exec jekyll build

    - name: 通过 SCP 上传到服务器
      uses: appleboy/scp-action@master
      with:
        host: ${{ secrets.SSH_HOST }}
        username: ${{ secrets.SSH_USER }}
        key: ${{ secrets.SSH_KEY }}
        source: "_site/*"
        target: "/home/ubuntu/chirpy-site"  # 替换为服务器上的部署路径

    - name: 远程重启 Docker 服务
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.SSH_HOST }}
        username: ${{ secrets.SSH_USER }}
        key: ${{ secrets.SSH_KEY }}
        script: |
          cd /home/ubuntu/chirpy-deploy
          docker-compose down
          docker-compose up --build -d
```

 注意：

- `_site/*` 是构建好的静态网页，会通过 SSH 上传到服务器
- `chirpy-deploy` 是服务器上的部署目录，里面包含 Dockerfile、docker-compose.yml
- `_site` 也可以不传，改成构建后打包 Docker 镜像上传（更高级部署方式）

#### 服务器端部署准备

1. 创建部署目录，例如 `/home/ubuntu/chirpy-deploy/`

2. 上传 `Dockerfile` 和 `docker-compose.yml` 到此目录

3. 确保端口 80 已打开，或配合 nginx 反向代理（可加 HTTPS）

4. GitHub Actions 每次 push 都会自动上传 `_site/` 并在此目录重新构建容器
