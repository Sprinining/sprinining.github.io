---
title: constexpr关键字
date: 2025-06-18 11:38:35 +0800
categories: [cpp, cpp basics]
tags: [CPP, constexpr]
description: "constexpr 指定常量表达式，表示变量或函数可在编译期求值，提高效率并保证常量性质。"
---
## constexpr 关键字

`constexpr` 表示“**编译期常量**”，即表达式、变量或函数的值**必须**能在**编译期**被求出来。

### 与 const 的区别

| `const`                      | `constexpr`                          |
| ---------------------------- | ------------------------------------ |
| 表示“只读”（不可修改）       | 表示“编译期常量表达式”               |
| 值可能是运行期确定           | 值**必须是编译期可确定**             |
| 可用于任何类型               | 要求类型支持编译期使用（字面值类型） |
| 可修饰对象、成员函数、指针等 | 可修饰变量、函数、构造函数、对象等   |
| 不等价于常量表达式           | 一定是常量表达式                     |

```cpp
const int x = rand();     // 运行时常量
constexpr int y = rand(); // 错误：不是编译期常量
```

### 常见用法

| 场景         | 示例                              | 意义                         |
| ------------ | --------------------------------- | ---------------------------- |
| 修饰变量     | `constexpr int a = 5;`            | `a` 是编译期常量             |
| 修饰函数     | `constexpr int add(int a, int b)` | 函数在编译期就可以被求值     |
| 修饰构造函数 | `constexpr MyClass(int)`          | 可用于生成编译期常量对象     |
| 修饰类       | 类内所有成员/函数均是 `constexpr` | 表示可在编译期完全构造和使用 |

#### 修饰变量

##### 编译期常量 (`constexpr`) 与运行期变量

```cpp
// 正例
constexpr int size = 10;
int arr[size];  // size 是常量表达式，可以作为数组大小

// 反例
int n = 10;             
constexpr int x = n;    // 错误：n 不是编译期常量表达式
```

- 虽然 `n` 的值是 10，但它是**普通变量初始化**，没有常量表达式语义。
- 编译器允许在程序中改变 `n` 的值（语义上仍然是运行期变量）。
- 编译器不会自动把它当作编译期常量，也不会去验证它是否可在编译期求值。

##### 条件允许的情况

```cpp
const int n = 10;       
constexpr int x = n;    // 许多实现允许，因为 n 的值在编译期已知
```

- 这里 `n` 用 `const` 声明，并且初始化值是编译期已知的字面量。
- 所以 `n` 本身是**常量表达式**，可以赋给 `constexpr` 变量。

```cpp
constexpr int n = 10;   
constexpr int x = n;    // 完全合法
```

- `constexpr` 明确告诉编译器：该值必须在编译期可求值。

#### 修饰函数（C++11 起）

```cpp
constexpr int add(int a, int b) {
    return a + b;
}
```

- 如果 `a` 和 `b` 是编译期常量（如字面值），`add(a, b)` 也将在编译期求值；

- 如果 `a` 和 `b` 是运行时值，`add(a, b)` 仍然是普通函数，在运行时执行。
- 特点：
  - **可在编译期执行**（只要实参都是常量表达式）；
  - **也可以在运行时执行**；
  - 被 `constexpr` 修饰的是“函数本身可以在编译期执行”，不是说“调用它的返回值一定是常量”。

函数要求：

- 函数体内只能有 **一条 return 语句（C++11）**

- 传入和返回类型必须是**字面类型**

- **C++14+** 起支持复杂函数体，允许 `if`、循环等语法

#### 修饰构造函数

```cpp
struct Point {
    int x, y;
    constexpr Point(int a, int b) : x(a), y(b) {}
};

constexpr Point p(1, 2);  // 编译期创建 Point 对象
```

#### 修饰类

C++20 起可以声明类为 `constexpr`：

```cpp
struct constexpr_string {
    char data[100];
    constexpr constexpr_string(const char* s) {
        // 编译期拷贝字符串
    }
};
```

#### 用于模板参数

```cpp
template<int N>
struct Array {
    int data[N];
};

constexpr int n = 8;
Array<n> arr;
```

#### 与 if constexpr 搭配（C++17）

```cpp
template<typename T>
void print_type_info() {
    if constexpr (std::is_integral_v<T>) {
        std::cout << "int type\n";
    } else {
        std::cout << "non-int type\n";
    }
}
```

- 这段代码**在编译期根据类型 `T` 判断，选择打印整型类型信息还是非整型类型信息**。

- 使用 `if constexpr` 让代码更加灵活和高效，避免无用代码编译。

- 只编译满足条件的分支，**不会导致模板实例化错误**。

### 编译器判断 constexpr 的标准

1. 语义上必须明确可在编译期求值（如无 `throw`、无 I/O、无运行时分支）
2. 所有使用到的值、调用的函数也都必须是 `constexpr`
3. 对象在 `constexpr` 上下文中被使用时，必须能推导出唯一值

### C++ 标准对 constexpr 的演进

| C++版本 | 特性进化                                              |
| ------- | ----------------------------------------------------- |
| C++11   | 支持 `constexpr` 变量和函数（必须是单 return 表达式） |
| C++14   | 放宽限制：允许 if、for、局部变量等                    |
| C++17   | 支持 `if constexpr`                                   |
| C++20   | 支持 `constexpr` 动态分配、虚函数等更多能力           |
| C++23   | `constexpr` lambda 支持更强的泛化与捕获               |

### “常量表达式” vs “constexpr 类型” vs “常量对象”

#### 常量表达式 —— **值层面**

一个能在编译期**求出结果**的表达式。

```cpp
constexpr int a = 10;      // 常量表达式
const int b = 20;          // 可能是常量表达式（看初始化表达式）
int c = 30;                // 不是常量表达式
```

判断标准：**这个表达式的结果能在编译期算出来吗？**

#### constexpr 类型 —— **类型层面** 

能被用作 `constexpr` 的类型。必须满足一定条件，使得编译器可以在**编译期完整构造并操作它的对象**。

| 是 `constexpr` 类型           | 不是                         |
| ----------------------------- | ---------------------------- |
| `int`, `char`, `bool`, 指针   | `std::string`, `std::vector` |
| `std::array<T, N>`            | 拥有虚函数的类               |
| 用户自定义 struct（满足要求） | 非字面值类                   |

一个类型要成为 `constexpr` 类型，通常要：

- 拥有 `constexpr` 构造函数
- 所有成员也必须是 `constexpr` 类型
- 没有虚函数（除非 C++20 起允许）
- 满足编译期构造的要求

用于非类型模板参数的对象类型，**必须是 `constexpr` 类型（字面值类型）**！

#### 常量对象 —— **对象层面**

**常量对象**通常就是指被 `const` 修饰的对象，意思是这个对象的值在其生命周期内不能被修改。

使用 `const` 或 `constexpr` 关键字声明的对象。

```cpp
const int a = 10;       // 常量对象（可能在编译期，也可能在运行期）
constexpr int b = 20;   // 编译期常量对象，一定是常量表达式
```

`const` 只是 **不可修改**，但不保证是常量表达式：

```cpp
int x = rand();
const int y = x;     // y 是常量对象，但不是常量表达式！
```

#### 示例

```cpp
#include <ctime>

constexpr int x = 42;               
// x 是 constexpr，必须在编译期求值
// 42 是编译期字面值
// x 是常量表达式（可以用于模板参数、数组长度、if constexpr 等）
// x 也是常量对象（不能修改）

const int y = time(0);              
// y 用 const 修饰，是常量对象（值不可修改）
// 但是 time(0) 是运行时函数调用
// y 不是常量表达式（值直到运行时才能确定）
// 不能用于模板参数或数组大小等要求编译期常量的地方

template<int N> struct A {};        

A<x> a1;  // 合法
// 模板参数要求编译期常量表达式
// x 是 constexpr 且值已知，编译器生成 A<42> 的实例

// A<y> a2;  // 不合法
// y 不是常量表达式，编译器无法在编译期确定其值
// 不能用作模板参数
```

### 字面类型

字面类型（**Literal Type**）是 C++ 中一个非常基础但很关键的概念，它决定了一个类型的值**能不能在编译期参与计算**，比如作为 `constexpr`、`consteval` 函数的参数或返回值，或者用在 `static_assert`、模板参数等上下文中。

字面类型就是那些可以在编译期构造并参与常量表达式求值的类型。

#### 字面类型的完整分类与标准定义（C++14/17）

##### 内建类型

- 所有算术类型：`int`, `char`, `float`, `double`, `bool`, `long`, `unsigned` 等
- 指针类型：`int*`, `void*`，甚至 `nullptr_t`
- 枚举类型（包括 `enum class`）
- `std::nullptr_t`

这些**天然就是**字面类型。

##### 结构体/类类型

当且仅当它满足以下全部条件：

| 条件项                                    | 解释                           |
| ----------------------------------------- | ------------------------------ |
| 必须有一个 `constexpr` 构造函数           | 用于在编译期构造对象           |
| 所有非静态成员必须是字面类型              | 成员类型也必须是可用于编译期的 |
| 析构函数是平凡（trivial）并且 `constexpr` | 避免运行时析构逻辑             |
| 不能有虚函数或虚基类                      | 这些依赖运行时多态机制         |
| 是完整类型（已定义，非前向声明）          | 编译期构造必须是完整类型       |

##### 数组类型

如果数组的元素类型是字面类型，那么该数组类型也是字面类型。

##### 指针和引用类型

- 所有指针类型，如 `int*`, `Point*`, `void*`，都是字面类型；
- 所有引用类型，如 `int&`, `const Point&`，也是字面类型。

类中有引用成员时，无法在编译期直接构造，所以它不是字面类型，也不能用于 constexpr 对象。

##### 联合体（union）

C++14 起，**满足条件的 `union` 也可以是字面类型**，但条件更严格：

- 所有成员都必须是字面类型；
- 没有虚函数/虚基类；
- 拥有 `constexpr` 构造函数；
- 析构必须是平凡的。

#### 非字面类型的一些常见情况

| 类型                    | 原因                          |
| ----------------------- | ----------------------------- |
| `std::string`           | 非平凡构造/析构，内部有堆内存 |
| 包含 `std::vector` 成员 | 成员不是字面类型              |
| 包含虚函数的类          | 有虚表指针，不能编译期构造    |
| 成员是引用类型          | 引用不能参与 constexpr 构造   |
