---
title: c++11大括号初始化
date: 2024-08-19 07:11:59 +0800
categories: [cpp, ccpp basics]
tags: [CPP, Curly Brackets Initialization]
description: 
---
## C++11大括号初始化

C++11可以将{}初始化器用于任何类型（可以用等号，也可以不用）

### 1. 数组、集合初始化

在C++11中，集合（列表）的初始化已经成为C++的一个基本功能，被称为“初始化列表”：

```c++
// C++98支持，C++11支持
int a[] = {1, 2, 3};
// C++98不支持，C++11支持
int b[]{2, 3, 4};
// C++98不支持，C++11支持
vector<int> c{1, 2, 3};
// C++98不支持，C++11支持
map<int, float> d = { {1, 1.0f},
                     {2, 2.0f},
                     {3, 3.0f}};
```

在C++11中，自动变量和全局变量的初始化方式包括：

```c++
// 1.等号加上赋值表达式
int t1 = 1 + 2;
// 2.等号加上大括号表达式的初始化列表
int t2 = {1 + 2};
// 3.大括号式的初始化列表
int t3{1 + 2};
int *t4 = new int{10};
// 4.小括号式的表达式列表
int t6(3 + 4);
int *t7 = new int(10);
```

### 2. 类成员初始化

C++98中如果静态成员不满足常量性，不能就地声明，且而且即使常量的静态成员也只能是整型或枚举型才能就地初始化。

C++11中，除了初始化列表（在构造函数中初始化）外，允许使用等=或花括号{}进行就地的**非静态成员变量**初始化：

```c++
struct Node {
    int value = 1;
};
```

如果在一个类中，既使用了就地初始化来初始化非静态成员变量，又在构造函数中使用了初始化列表，执行顺序是：先执行就地初始化，然后执行初始化列表。

### 3. 自定义类型初始化

标准模板库STL中容器对初始化列表的支持源于<initializer_list>头文件中initialize_list类模板的支持。程序员只要#include<initializer_list>并声明一个以initialize_List<T>模板类为参数的构造函数,也可以使得自定义类使用列表初始化。

### 4. 变量会不会初始化取决于什么

#### 变量的存储位置和生命周期

| 存储位置                               | 是否默认初始化                  | 备注                       |
| -------------------------------------- | ------------------------------- | -------------------------- |
| **全局变量/静态变量**（包括静态数组）  | ✅ 默认被初始化为零（所有位为0） | 程序开始前由运行时自动清零 |
| **局部变量（函数内定义的非静态变量）** | ❌ 不初始化，内容是垃圾值        | 栈上分配，未赋值前不可读   |
| **静态局部变量**                       | ✅ 默认被初始化为零              | 比如 `static int arr[10];` |
| **动态分配的数组**                     | ❌ 不初始化（未初始化内存）      | `new int[10];`不初始化     |
| **使用 `new int[10]()`**               | ✅ 值初始化，初始化为0           | 注意带括号的 new 会初始化  |

#### 类型本身

- **内置类型（如 `int`, `char` 等）**：默认不初始化（除静态/全局变量外）
- **类类型**：调用默认构造函数，可能会自动初始化（取决于类定义）
