---
title: stack
date: 2024-08-20 10:42:10 +0800
categories: [cpp, stl]
tags: [CPP, CPP STL]
description: "stack 是容器适配器，遵循后进先出（LIFO）原则，仅允许访问栈顶元素，常用于括号匹配、表达式求值等场景。"
---
## stack

`std::stack` 是一个 **容器适配器（container adapter）**，用于模拟 **后进先出（LIFO）** 的栈结构。

它 **封装了一个底层容器**（默认是 `deque`），并 **仅暴露部分接口**（如 `push`, `pop`, `top`），从而屏蔽掉底层容器的其余功能。

### 常见接口

```cpp
#include <stack>
using namespace std;

stack<int> s;
s.push(1);      // 入栈
s.push(2);
s.top();        // 查看栈顶（不弹出），返回 2
s.pop();        // 弹出栈顶，栈变为 [1]
s.empty();      // 判断是否为空
s.size();       // 返回元素个数
```

接口列表：

| 接口        | 说明                   |
| ----------- | ---------------------- |
| `push(x)`   | 入栈                   |
| `pop()`     | 出栈（移除栈顶元素）   |
| `top()`     | 查看栈顶元素（不移除） |
| `empty()`   | 是否为空               |
| `size()`    | 元素个数               |
| `emplace()` | 原地构造元素（C++11）  |

### 底层原理

stack 本质上是对底层容器的封装（默认 `deque`）：

```cpp
template<
    class T,
    class Container = std::deque<T>
> class stack;
```

也可以指定 `vector<T>` 或 `list<T>` 作为底层容器：

```cpp
stack<int, vector<int>> s1;
stack<int, list<int>> s2;
```

要求底层容器必须支持：`back()`, `push_back()`, `pop_back()`。

### 示例代码

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> s;
    for (int i = 1; i <= 5; ++i) s.push(i);  // 入栈 1~5

    while (!s.empty()) {
        cout << s.top() << " ";  // 5 4 3 2 1
        s.pop();
    }
}
```

### 使用场景举例

- 表达式求值（中缀转后缀、逆波兰表达式）
- 括号匹配
- 深度优先搜索（DFS）
- 回溯/撤销操作
- 浏览器前进/后退功能模拟

### 常见问题

1. **`stack` 能用哪些容器做底层？为啥默认是 `deque`？**
   - 要求底层容器支持 `back()`, `push_back()`, `pop_back()`
   - `deque` 支持更快的尾部插入删除，且可双端扩展，默认更安全
2. **能不能遍历 `stack`？**
   - ❌ 不能，`stack` 故意不暴露迭代器
   - 若需遍历，可用 `vector` 实现类栈行为
3. **stack 的线程安全性？**
   - STL 的容器默认不是线程安全的，需用户自行加锁
4. **top() 后能否继续使用栈？**
   - 可以，`top()` 不会移除元素，`pop()` 才会

### 注意事项

- `stack.pop()` **不会返回值**！你要先用 `top()` 获取，再 `pop()`。

  ```cpp
  int x = s.top();
  s.pop();  // 正确方式
  ```

- 不支持遍历（无 `begin()`/`end()`），如需遍历请用其他容器模拟。

- C++ STL `stack` 是**容器适配器**，并非底层容器，效率受限于其底层实现。
