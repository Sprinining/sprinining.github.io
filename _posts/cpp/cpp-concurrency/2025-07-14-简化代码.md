---
title: ç®€åŒ–ä»£ç 
date: 2025-07-14 14:32:51 +0800
categories: [cpp, cpp concurrency]
tags: [CPP, Concurrency]
description: ""
---
## ç®€åŒ–ä»£ç 

### ä½¿ç”¨ future çš„å‡½æ•°åŒ–ç¼–ç¨‹

#### å‡½æ•°åŒ–ç¼–ç¨‹ç®€ä»‹

**å‡½æ•°åŒ–ç¼–ç¨‹ï¼ˆFunctional Programmingï¼ŒFPï¼‰**æ˜¯ä¸€ç§ç¼–ç¨‹èŒƒå¼ï¼Œå¼ºè°ƒå‡½æ•°çš„çº¯ç²¹æ€§ã€‚çº¯å‡½æ•°çš„ç‰¹ç‚¹æ˜¯ï¼š

- å‡½æ•°ç»“æœåªä¾èµ–äºä¼ å…¥çš„å‚æ•°ï¼›
- å¯¹ç›¸åŒçš„è¾“å…¥å‚æ•°ï¼Œå¤šæ¬¡è°ƒç”¨å‡½æ•°éƒ½ä¼šå¾—åˆ°ç›¸åŒçš„ç»“æœï¼›
- å‡½æ•°ä¸ä¼šæ”¹å˜ä»»ä½•å¤–éƒ¨çŠ¶æ€ã€‚

C++æ ‡å‡†åº“ä¸­è®¸å¤šæ•°å­¦ç›¸å…³å‡½æ•°éƒ½ç¬¦åˆè¿™ä¸€ç‰¹æ€§ï¼Œä¾‹å¦‚ï¼š`sin`ã€`cos`ã€`sqrt`ï¼Œä»¥åŠåŸºæœ¬ç±»å‹ä¹‹é—´çš„è¿ç®—å¦‚ `3+3`ã€`6*9`ã€`1.3/4.7` ç­‰ã€‚

å‡½æ•°åŒ–ç¼–ç¨‹å¸¦æ¥çš„å¥½å¤„ä¹‹ä¸€æ˜¯é¿å…æ¡ä»¶ç«äº‰é—®é¢˜ã€‚å› ä¸ºçº¯å‡½æ•°ä¸ä¿®æ”¹å…±äº«æ•°æ®ï¼Œæ‰€ä»¥ä¸å­˜åœ¨æ•°æ®ç«äº‰ï¼Œä¹Ÿä¸éœ€è¦äº’æ–¥é‡ä¿æŠ¤æ•°æ®ã€‚ä¾‹å¦‚ï¼ŒHaskell è¯­è¨€ä¸­æ‰€æœ‰å‡½æ•°é»˜è®¤éƒ½æ˜¯çº¯å‡½æ•°ã€‚

C++ä½œä¸ºå¤šèŒƒå‹è¯­è¨€ï¼Œä¹Ÿå¯ä»¥æ”¯æŒå‡½æ•°å¼ç¼–ç¨‹é£æ ¼ã€‚C++11å¼•å…¥çš„Lambdaè¡¨è¾¾å¼ã€`std::bind`ã€è‡ªåŠ¨ç±»å‹æ¨æ–­ï¼ˆ`auto`å…³é”®å­—ï¼‰ç­‰ç‰¹æ€§ï¼Œä½¿å¾—å‡½æ•°å¼ç¼–ç¨‹åœ¨C++ä¸­å˜å¾—æ›´åŠ ç®€æ´ã€‚`future`ä½œä¸ºå¼‚æ­¥ä»»åŠ¡çš„ç»“æœä¼ é€’æœºåˆ¶ï¼Œä¸ºFPé£æ ¼çš„å¹¶å‘ç¼–ç¨‹æä¾›äº†é‡è¦æ”¯æŒã€‚

#### å¿«é€Ÿæ’åºçš„å‡½æ•°åŒ–ç¼–ç¨‹å®ç°ï¼ˆä¸²è¡Œç‰ˆï¼‰

![4-2](/assets/media/pictures/cpp/ç®€åŒ–ä»£ç .assets/4-2.png)

ä¸‹é¢æ˜¯å¿«é€Ÿæ’åºç®—æ³•çš„å‡½æ•°å¼ä¸²è¡Œå®ç°ã€‚è¯¥å‡½æ•°æ¥å—ä¸€ä¸ª`std::list<T>`ï¼Œè¿”å›ä¸€ä¸ªæ’åºåçš„æ–°åˆ—è¡¨ï¼Œä¸`std::sort()`ä¸åŒï¼Œåè€…æ˜¯å°±åœ°æ’åºï¼Œæ²¡æœ‰è¿”å›å€¼ã€‚

```cpp
template<typename T>
std::list<T> sequential_quick_sort(std::list<T> input) {
  if(input.empty()) {
    return input;
  } 
  
  std::list<T> result;
  result.splice(result.begin(), input, input.begin());  // â‘  å°†ç¬¬ä¸€ä¸ªå…ƒç´ ä½œä¸ºåŸºå‡†(pivot)ç§»åŠ¨åˆ°ç»“æœåˆ—è¡¨
  T const& pivot = *result.begin();                     // â‘¡ ä½¿ç”¨å¼•ç”¨é¿å…æ‹·è´
  
  // â‘¢ ä½¿ç”¨std::partitionæ ¹æ®pivotåˆ’åˆ†åˆ—è¡¨ï¼Œå°äºpivotçš„å…ƒç´ æ”¾å‰é¢
  auto divide_point = std::partition(input.begin(), input.end(),
                                     [&](T const& t){ return t < pivot; });
  
  std::list<T> lower_part;
  // â‘£ å°†å°äºpivotçš„å…ƒç´ ç§»åŠ¨åˆ°lower_partåˆ—è¡¨
  lower_part.splice(lower_part.end(), input, input.begin(), divide_point);
  
  // â‘¤ é€’å½’æ’åºå°äºpivotéƒ¨åˆ†
  auto new_lower = sequential_quick_sort(std::move(lower_part));
  // â‘¥ é€’å½’æ’åºå¤§äºç­‰äºpivotéƒ¨åˆ†
  auto new_higher = sequential_quick_sort(std::move(input));
  
  // â‘¦ ç»“æœæ‹¼æ¥ï¼šå…ˆæ‹¼æ¥å¤§äºéƒ¨åˆ†
  result.splice(result.end(), new_higher);
  // â‘§ å†æ‹¼æ¥å°äºéƒ¨åˆ†
  result.splice(result.begin(), new_lower);
  
  return result;
}
```

**è¯´æ˜ï¼š**

- `splice()`æ“ä½œé¿å…äº†ä¸å¿…è¦çš„æ‹·è´ï¼Œé€šè¿‡è½¬ç§»é“¾è¡¨èŠ‚ç‚¹å®ç°é«˜æ•ˆç§»åŠ¨ã€‚
- ä½¿ç”¨Lambdaè¡¨è¾¾å¼å®šä¹‰`partition`çš„åˆ¤å®šæ¡ä»¶ã€‚
- è¯¥å®ç°çš„æ¥å£æ˜¯å‡½æ•°å¼çš„ï¼Œè¾“å…¥ä¸è¢«ä¿®æ”¹ï¼Œè¾“å‡ºä¸ºæ–°çš„æ’åºåˆ—è¡¨ã€‚

#### å¿«é€Ÿæ’åºçš„å‡½æ•°åŒ–å¹¶å‘å®ç°ï¼ˆå¹¶è¡Œç‰ˆï¼‰

åŸºäºä¸Šè¿°ä¸²è¡Œå®ç°ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨`std::async`å¹¶å‘æ‰§è¡Œæ’åºä»»åŠ¡ï¼Œä»è€ŒåŠ é€Ÿæ’åºè¿‡ç¨‹ï¼š

```cpp
// å¹¶è¡Œç‰ˆæœ¬çš„å¿«é€Ÿæ’åºï¼Œä½¿ç”¨ std::future å¼‚æ­¥æ’åºæŸéƒ¨åˆ†æ•°æ®
template<typename T>
std::list<T> parallel_quick_sort(std::list<T> input) {
  // å¤„ç†ç©ºåˆ—è¡¨çš„æƒ…å†µï¼Œç›´æ¥è¿”å›
  if(input.empty()) {
    return input;
  }

  std::list<T> result;

  // å°† input çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ˆé€‰ä½œ pivotï¼‰â€œæŒªâ€åˆ° result çš„å¼€å¤´
  // è¿™ä¹Ÿæ˜¯æˆ‘ä»¬åé¢è¦æ¯”è¾ƒå’Œæ‹¼æ¥çš„â€œåŸºå‡†å€¼â€
  result.splice(result.begin(), input, input.begin());

  // å–å‡ºåˆšè½¬ç§»è¿‡æ¥çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä½œä¸º pivot
  T const& pivot = *result.begin();

  // ä½¿ç”¨ partition æŠŠ input ä¸­çš„å…ƒç´ æŒ‰ pivot åˆ†æˆä¸¤éƒ¨åˆ†ï¼š
  // å°äº pivot çš„æ”¾å‰é¢ï¼Œå…¶ä½™æ”¾åé¢
  auto divide_point = std::partition(input.begin(), input.end(),
                                     [&](T const& t){ return t < pivot; });

  std::list<T> lower_part;

  // å°†å°äº pivot çš„éƒ¨åˆ†ï¼ˆä» input.begin() åˆ° divide_pointï¼‰â€œæŒªâ€åˆ° lower_part
  lower_part.splice(lower_part.end(), input, input.begin(), divide_point);

  // ä½¿ç”¨ std::async å¼‚æ­¥åœ°å¯¹ lower_part æ‰§è¡Œå¹¶è¡Œå¿«é€Ÿæ’åº
  // std::move(lower_part) é¿å…æ‹·è´ï¼Œæé«˜æ•ˆç‡
  // è¿”å›ä¸€ä¸ª futureï¼Œç¨åè°ƒç”¨ .get() è·å–æ’åºç»“æœ
  std::future<std::list<T>> new_lower(
      std::async(&parallel_quick_sort<T>, std::move(lower_part))
  );

  // å½“å‰çº¿ç¨‹ç»§ç»­é€’å½’æ’åºå‰©ä¸‹éƒ¨åˆ†ï¼ˆinputä¸­å¤§äºç­‰äº pivot çš„éƒ¨åˆ†ï¼‰
  auto new_higher = parallel_quick_sort(std::move(input));

  // æ‹¼æ¥æ’åºç»“æœï¼š
  // å…ˆæ‹¼æ¥å¤§äºéƒ¨åˆ†åˆ° result å°¾éƒ¨ï¼ˆé¡ºåºæ˜¯ï¼š[pivot] + new_higherï¼‰
  result.splice(result.end(), new_higher);

  // å†é€šè¿‡ future.get() è·å–å¼‚æ­¥æ’åºç»“æœï¼Œæ‹¼æ¥åˆ° result å¤´éƒ¨
  // æœ€ç»ˆé¡ºåºæ˜¯ï¼š[new_lower] + [pivot] + [new_higher]
  result.splice(result.begin(), new_lower.get());

  // è¿”å›æ’åºåçš„ç»“æœ
  return result;
}
```

**è¯´æ˜ï¼š**

- `std::async`ä¼šä¸º`new_lower`å¯åŠ¨ä¸€ä¸ªæ–°çº¿ç¨‹æ‰§è¡Œæ’åºã€‚
- é€šè¿‡é€’å½’è°ƒç”¨`parallel_quick_sort`ï¼Œå¯ä»¥åˆ©ç”¨å¤šæ ¸ç¡¬ä»¶å®ç°å¹¶è¡Œè®¡ç®—ã€‚
- å½“é€’å½’å±‚æ•°å¢åŠ æ—¶ï¼Œçº¿ç¨‹æ•°é‡å¯èƒ½æ€¥å‰§ä¸Šå‡ï¼ˆä¾‹å¦‚é€’å½’10å±‚å¯èƒ½äº§ç”Ÿ1024ä¸ªçº¿ç¨‹ï¼‰ï¼Œè¿è¡Œåº“å¯èƒ½ä¼šè‡ªåŠ¨æ§åˆ¶çº¿ç¨‹çš„åˆ›å»ºï¼Œä»¥é¿å…è¿‡åº¦å¼€é”€ã€‚
- `new_lower.get()`ä¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°å¼‚æ­¥ä»»åŠ¡å®Œæˆï¼Œå–å¾—ç»“æœã€‚

#### spawn_task å‡½æ•°ç¤ºä¾‹

ç›¸æ¯”ç›´æ¥ä½¿ç”¨`std::async`ï¼Œæœ‰æ—¶éœ€è¦æ›´çµæ´»çš„ä»»åŠ¡å¯åŠ¨æ–¹å¼ã€‚ä¸‹é¢ç¤ºä¾‹æ˜¯ä½¿ç”¨`std::packaged_task`å’Œ`std::thread`å°è£…çš„ç®€å•ä»»åŠ¡å¯åŠ¨å‡½æ•°`spawn_task`ï¼š

```cpp
// é€šç”¨å¼‚æ­¥ä»»åŠ¡å°è£…å™¨ï¼šå°†ä¸€ä¸ªå‡½æ•°fåŠå…¶å‚æ•°aåŒ…è£…æˆä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡å¹¶å¯åŠ¨çº¿ç¨‹æ‰§è¡Œï¼Œè¿”å› future ç”¨äºè·å–ç»“æœ
template<typename F, typename A>
std::future<typename std::result_of<F(A&&)>::type>
spawn_task(F&& f, A&& a) {
  // æ¨å¯¼å‡½æ•° f(A&&) çš„è¿”å›ç±»å‹ä½œä¸ºä»»åŠ¡ç»“æœç±»å‹ï¼ˆC++11 ä½¿ç”¨ result_ofï¼ŒC++14 èµ·å»ºè®®ç”¨ invoke_resultï¼‰
  typedef typename std::result_of<F(A&&)>::type result_type;

  // åˆ›å»ºä¸€ä¸ª packaged_taskï¼šå®ƒå°è£…äº†å‡½æ•° fï¼Œå¯å¼‚æ­¥æ‰§è¡Œå¹¶å°†ç»“æœå­˜å…¥ future ä¸­
  std::packaged_task<result_type(A&&)> task(std::move(f));

  // è·å– futureï¼Œç”¨äºå¼‚æ­¥ç»“æœè®¿é—®
  std::future<result_type> res(task.get_future());

  // å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹ï¼Œæ‰§è¡Œä»»åŠ¡ taskï¼Œä¼ å…¥å‚æ•° a
  // æ³¨æ„ task å’Œ a éƒ½è¦ç”¨ std::move ä»¥é¿å…æ‹·è´ï¼Œæé«˜æ•ˆç‡
  std::thread t(std::move(task), std::move(a));

  // å°†çº¿ç¨‹åˆ†ç¦»ï¼Œäº¤ç”±åå°è¿è¡Œï¼ˆæ— éœ€è°ƒç”¨ joinï¼‰
  t.detach();

  // è¿”å› futureï¼Œä¾›è°ƒç”¨è€…ç¨åä½¿ç”¨ get() è·å–ç»“æœ
  return res;
}
```

**è¯´æ˜ï¼š**

- `std::packaged_task`åŒ…è£…ä¸€ä¸ªå¯è°ƒç”¨å¯¹è±¡ï¼Œå…è®¸é€šè¿‡`future`è·å–æ‰§è¡Œç»“æœã€‚
- `std::thread`å¯åŠ¨æ–°çº¿ç¨‹æ‰§è¡Œä»»åŠ¡ï¼Œä¸»çº¿ç¨‹è¿”å›`future`ã€‚
- è¿™ç§æ–¹å¼æ–¹ä¾¿åç»­æ”¹é€ æˆçº¿ç¨‹æ± ä»»åŠ¡æäº¤æ¥å£ã€‚
- ç›´æ¥ä½¿ç”¨`std::async`æ›´é€‚åˆå·²çŸ¥æ‰€æœ‰ä»»åŠ¡ä¸”éœ€è¦è‡ªåŠ¨ç®¡ç†çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸçš„æƒ…å†µã€‚

#### é¢å¤–è¯´æ˜

- `std::partition`æœ¬èº«æ˜¯ä¸²è¡Œçš„ï¼Œè‹¥è¿½æ±‚æœ€å¿«çš„å¹¶è¡Œæ’åºï¼Œå¯ä»¥è€ƒè™‘C++17ä¸­å¹¶è¡Œç®—æ³•æ”¯æŒï¼ˆåç»­ç« èŠ‚ä¼šä»‹ç»ï¼‰ã€‚
- å‡½æ•°å¼ç¼–ç¨‹ä¹Ÿæ˜¯å¹¶å‘ç¼–ç¨‹çš„ä¸€ä¸ªèŒƒå¼ï¼Œç±»ä¼¼äºé€šè®¯é¡ºåºè¿›ç¨‹ï¼ˆCSPï¼‰ï¼Œçº¿ç¨‹é—´é€šè¿‡æ¶ˆæ¯ä¼ é€’è€Œä¸æ˜¯å…±äº«çŠ¶æ€ã€‚
- Erlangè¯­è¨€å’ŒMPIéƒ½æ˜¯åŸºäºæ­¤èŒƒå¼çš„é«˜æ€§èƒ½å¹¶è¡Œç¼–ç¨‹å®è·µã€‚
- C++é€šè¿‡`future`å’Œå¼‚æ­¥ä»»åŠ¡æœºåˆ¶æ”¯æŒäº†è¿™ç§å¹¶å‘ç¼–ç¨‹é£æ ¼ã€‚

### ä½¿ç”¨æ¶ˆæ¯ä¼ é€’çš„åŒæ­¥æ“ä½œ

#### CSPç®€ä»‹ï¼šæ— å…±äº«æ•°æ®çš„çº¿ç¨‹æ¨¡å‹

**CSPï¼ˆCommunicating Sequential Processesï¼‰** æ˜¯ä¸€ç§å¹¶å‘æ¨¡å‹ï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š

- **çº¿ç¨‹ä¹‹é—´ä¸å…±äº«æ•°æ®**ï¼›
- æ¯ä¸ªçº¿ç¨‹åªé€šè¿‡æ¥æ”¶â€œæ¶ˆæ¯â€è¿›è¡ŒçŠ¶æ€è½¬æ¢ï¼›
- æ¯ä¸ªçº¿ç¨‹å¯ä»¥è¢«å»ºæ¨¡ä¸ºä¸€ä¸ª**æœ‰é™çŠ¶æ€æœº**ï¼ˆFSMï¼‰ï¼›
- æ¶ˆæ¯ä¼ é€’æ–¹å¼æå¤§ç®€åŒ–äº†å¹¶å‘ç¨‹åºçš„è®¾è®¡ä¸ç»´æŠ¤ã€‚

C++ çº¿ç¨‹æœ¬è´¨ä¸Šå…±äº«åœ°å€ç©ºé—´ï¼Œå¹¶ä¸å¤©ç„¶æ”¯æŒ CSPï¼Œä½†é€šè¿‡è§„èŒƒè®¾è®¡ï¼ˆæ¯”å¦‚æ¶ˆæ¯ä¼ é€’é˜Ÿåˆ—ï¼‰å¯ä»¥æ¨¡æ‹Ÿå‡ºç±»ä¼¼è¡Œä¸ºã€‚

#### ç¤ºä¾‹åœºæ™¯ï¼šATM è‡ªåŠ¨å–æ¬¾æœº

è®¾è®¡ä¸€ä¸ª ATM ç³»ç»Ÿï¼Œå…¶åŠŸèƒ½åŒ…æ‹¬ï¼š

- æ¥æ”¶å¡ç‰‡ã€æ˜¾ç¤ºä¿¡æ¯ã€å“åº”æŒ‰é’®ï¼›
- ä¸é“¶è¡Œé€šä¿¡è¿›è¡Œ PIN éªŒè¯ä¸è´¦æˆ·äº¤æ˜“ï¼›
- åé’ã€é€€å¡ã€‚

çº¿ç¨‹åˆ†å·¥ç¤ºæ„ï¼š

| çº¿ç¨‹         | åŠŸèƒ½                       |
| ------------ | -------------------------- |
| ç¡¬ä»¶æ¥å£çº¿ç¨‹ | å¤„ç†æŒ‰é’®ã€åé’ã€é€€å¡ç­‰æœºæ¢° |
| ATM é€»è¾‘çº¿ç¨‹ | çŠ¶æ€æœºæ§åˆ¶ã€å¤„ç†ç”¨æˆ·æ“ä½œ   |
| é“¶è¡Œé€šä¿¡çº¿ç¨‹ | ä¸é“¶è¡Œåç«¯äº¤äº’             |

è¿™äº›çº¿ç¨‹ä¹‹é—´é€šè¿‡æ¶ˆæ¯ä¼ é€’é€šä¿¡ï¼Œäº’ä¸å…±äº«æ•°æ®ã€‚

#### ATM çŠ¶æ€æœºæ¨¡å‹ï¼ˆç®€åŒ–ï¼‰

![4-3](/assets/media/pictures/cpp//ç®€åŒ–ä»£ç .assets/4-3.png)

#### ATM é€»è¾‘ç±»ä»£ç å®ç°

##### ATM çŠ¶æ€æœºç±»ç»“æ„

```cpp
struct card_inserted {
  std::string account;  // è¡¨ç¤ºæ’å¡ä¿¡æ¯
};

class atm {
  messaging::receiver incoming;                // æ¶ˆæ¯æ¥æ”¶å™¨ï¼ˆè‡ªå·±çš„æ¶ˆæ¯é˜Ÿåˆ—ï¼‰
  messaging::sender bank;                      // å‘ç»™é“¶è¡Œçš„æ¶ˆæ¯å‘é€å™¨
  messaging::sender interface_hardware;        // å‘ç»™ç•Œé¢/è®¾å¤‡çš„æ¶ˆæ¯å‘é€å™¨
  void (atm::*state)();                        // å½“å‰çŠ¶æ€å¯¹åº”çš„æˆå‘˜å‡½æ•°æŒ‡é’ˆ

  std::string account;                         // å½“å‰è´¦æˆ·
  std::string pin;                             // å½“å‰PINç 

  void waiting_for_card()  // ç­‰å¾…æ’å¡çŠ¶æ€
  {
    interface_hardware.send(display_enter_card());  // æ˜¾ç¤ºâ€œè¯·æ’å¡â€æç¤º

    incoming.wait()                                 // ç­‰å¾…æ¥æ”¶åˆ°æ¶ˆæ¯
      .handle<card_inserted>(                       // å¤„ç†card_insertedç±»å‹æ¶ˆæ¯
        [&](card_inserted const& msg) {
          account = msg.account;                    // ä¿å­˜è´¦æˆ·
          pin = "";                                 // æ¸…ç©ºPIN
          interface_hardware.send(display_enter_pin());  // æç¤ºè¾“å…¥PIN
          state = &atm::getting_pin;                // çŠ¶æ€åˆ‡æ¢ä¸ºè·å–PIN
        });
  }

  void getting_pin();  // è·å–PINçš„çŠ¶æ€å‡½æ•°ï¼ˆç¨åç»™å‡ºï¼‰

public:
  void run()  // ä¸»å¾ªç¯ï¼Œåå¤è°ƒç”¨å½“å‰çŠ¶æ€å‡½æ•°
  {
    state = &atm::waiting_for_card;  // åˆå§‹çŠ¶æ€ä¸ºç­‰å¾…æ’å¡
    try {
      for (;;) {
        (this->*state)();            // è°ƒç”¨å½“å‰çŠ¶æ€å¯¹åº”çš„æˆå‘˜å‡½æ•°
      }
    } catch (messaging::close_queue const&) {
      // é˜Ÿåˆ—å…³é—­å¼‚å¸¸é€€å‡ºå¾ªç¯
    }
  }
};
```

##### ATM çš„ PIN å¤„ç†çŠ¶æ€å‡½æ•°

```cpp
void atm::getting_pin()
{
  incoming.wait()
    .handle<digit_pressed>(      // â‘  ç”¨æˆ·æŒ‰ä¸‹æ•°å­—é”®
      [&](digit_pressed const& msg) {
        unsigned const pin_length = 4;
        pin += msg.digit;        // ç´¯åŠ PINç 
        if(pin.length() == pin_length) {
          bank.send(verify_pin(account, pin, incoming)); // å‘é“¶è¡ŒéªŒè¯PIN
          state = &atm::verifying_pin;                   // çŠ¶æ€è½¬ç§»
        }
      })
    .handle<clear_last_pressed>(  // â‘¡ ç”¨æˆ·æ¸…é™¤ä¸Šä¸€ä¸ªæ•°å­—
      [&](clear_last_pressed const& msg) {
        if(!pin.empty()) {
          pin.resize(pin.length() - 1);  // åˆ é™¤æœ€åä¸€ä¸ªå­—ç¬¦
        }
      })
    .handle<cancel_pressed>(      // â‘¢ ç”¨æˆ·å–æ¶ˆæ“ä½œ
      [&](cancel_pressed const& msg) {
        state = &atm::done_processing;   // è½¬åˆ°å¤„ç†å®ŒæˆçŠ¶æ€
      });
}
```

#### ç¼–ç¨‹æ¨¡å‹æ€»ç»“ï¼šActor æ¨¡å¼

æœ¬ç³»ç»Ÿé‡‡ç”¨äº†**å‚ä¸è€…æ¨¡å‹ï¼ˆActor Modelï¼‰**ï¼Œç‰¹ç‚¹å¦‚ä¸‹ï¼š

| ç‰¹æ€§               | è¯´æ˜             |
| ------------------ | ---------------- |
| æ¯ä¸ªå‚ä¸è€…         | è¿è¡Œåœ¨ç‹¬ç«‹çº¿ç¨‹   |
| é€šè¿‡æ¶ˆæ¯é€šä¿¡       | è€Œéå…±äº«æ•°æ®     |
| æ˜ç¡®çš„çŠ¶æ€è½¬ç§»é€»è¾‘ | æ›´æ˜“å»ºæ¨¡å’Œæµ‹è¯•   |
| é«˜å¹¶å‘å‹å¥½         | æ¶ˆé™¤é”å’Œç«äº‰æ¡ä»¶ |

#### è¿è¡Œè¿‡ç¨‹å›é¡¾

```cpp
atm a;
a.run();  // è¿›å…¥çŠ¶æ€æœºä¸»å¾ªç¯
```

- åˆå§‹çŠ¶æ€ `waiting_for_card` ç­‰å¾…æ¶ˆæ¯ï¼›
- æ”¶åˆ° `card_inserted` åè¿›å…¥ `getting_pin`ï¼›
- åœ¨ `getting_pin` çŠ¶æ€ä¸­æ ¹æ®ä¸åŒæ¶ˆæ¯åšå‡ºç›¸åº”ååº”å¹¶ç»§ç»­è½¬æ¢çŠ¶æ€ï¼›
- æ¯æ¬¡çŠ¶æ€è½¬ç§»åï¼Œ`run()` ä¼šç»§ç»­æ‰§è¡Œå½“å‰çŠ¶æ€å‡½æ•°ã€‚

#### å°ç»“

é€šè¿‡æ¶ˆæ¯ä¼ é€’å®ç°åŒæ­¥çš„ç¼–ç¨‹æ¨¡å¼ï¼ˆå¦‚ Actor/CSPï¼‰ç›¸æ¯”ä¼ ç»Ÿå…±äº«å†…å­˜å¹¶å‘æ–¹å¼æœ‰å¦‚ä¸‹ä¼˜åŠ¿ï¼š

- æ¶ˆé™¤äº†äº’æ–¥ã€æ¡ä»¶å˜é‡ç­‰åŒæ­¥åŸè¯­çš„å¤æ‚æ€§ï¼›
- æ¯ä¸ªç»„ä»¶èŒè´£æ¸…æ™°ã€æ˜“äºæµ‹è¯•ï¼›
- çº¿ç¨‹å®‰å…¨æ€§å¤©ç„¶ç”±ç»“æ„ä¿è¯ï¼›
- ç‰¹åˆ«é€‚åˆ GUI äº‹ä»¶å¤„ç†ã€ç½‘ç»œé€šä¿¡ã€åˆ†å¸ƒå¼è®¡ç®—ç­‰åœºæ™¯ã€‚

è¿™ç§æ¨¡å¼å¯¹è®¾è®¡å’Œç¼–ç è€…æå‡ºæ›´é«˜çš„æ¶æ„èƒ½åŠ›è¦æ±‚ï¼Œä½†å¯¹å¤§è§„æ¨¡å¹¶å‘ç³»ç»Ÿå…·æœ‰å¤©ç„¶ä¼˜åŠ¿ã€‚

### æ‰©å±•è§„èŒƒä¸­çš„æŒç»­æ€§å¹¶å‘

ä½¿ç”¨ `std::experimental::future` å’Œ `then()` å®ç°å¼‚æ­¥æ“ä½œçš„**æŒç»­æ€§ï¼ˆcontinuationï¼‰**

#### èƒŒæ™¯ä¸åŠ¨æœº

åœ¨æ ‡å‡† `std::future` ä¸­ï¼š

- è·å–å¼‚æ­¥ç»“æœæ—¶å¿…é¡»è°ƒç”¨ `get()`ï¼›
- è·å–å‰éœ€ç­‰å¾…å…¶â€œå°±ç»ªâ€ï¼Œå¸¸ç”¨ `wait()` / `wait_for()` ç­‰é˜»å¡æ‰‹æ®µï¼›
- ç¼–å†™å¼‚æ­¥å¤„ç†é€»è¾‘è¾ƒä¸ºç¹çï¼Œä»£ç å¯è¯»æ€§å·®ã€‚

ä¸ºäº†è§£å†³è¿™äº›é—®é¢˜ï¼Œ**C++ å¹¶å‘æ‰©å±•è§„èŒƒï¼ˆTSï¼šTechnical Specificationï¼‰** å¼•å…¥äº†ï¼š

- `std::experimental::future`
- `std::experimental::promise`
- `then()`ï¼šå¯æ³¨å†Œä¸€ä¸ªâ€œæŒç»­æ€§æ“ä½œï¼ˆcontinuationï¼‰â€

#### ä»€ä¹ˆæ˜¯â€œæŒç»­æ€§â€ï¼Ÿ

**å®šä¹‰**ï¼šä¸€æ—¦ `future` è¾¾åˆ°â€œå°±ç»ªæ€â€ï¼Œç«‹å³è§¦å‘ `then()` ä¸­ç»‘å®šçš„å›è°ƒå‡½æ•°ã€‚

ä½ æ— éœ€æ‰‹åŠ¨ç­‰å¾…ã€åˆ¤æ–­çŠ¶æ€ï¼Œå¼‚æ­¥ç»“æœå‡†å¤‡å¥½æ—¶ï¼Œè‡ªåŠ¨è°ƒç”¨åç»­å¤„ç†é€»è¾‘ã€‚

#### åŸºæœ¬ç”¨æ³•ç¤ºä¾‹

```cpp
std::experimental::future<int> find_the_answer;
auto fut = find_the_answer();                 // å¼‚æ­¥å¯åŠ¨ä»»åŠ¡
auto fut2 = fut.then(find_the_question);      // æ³¨å†ŒæŒç»­æ€§æ“ä½œ

assert(!fut.valid());  // fut è¢«â€œæ¥ç®¡â€ï¼ŒåŸå§‹ future æ— æ•ˆ
assert(fut2.valid());  // fut2 æ˜¯ then() çš„è¿”å›å€¼ï¼ŒæŒæœ‰æ–°çš„ future
```

**æ³¨æ„äº‹é¡¹**ï¼š

- `fut.then()` ä¼šâ€œæ¥ç®¡â€åŸæ¥çš„ futureï¼Œä½¿åŸå§‹çš„ `fut` æ— æ•ˆï¼›
- `then()` è¿”å›ä¸€ä¸ªæ–°çš„ futureï¼ŒæŒæœ‰å›è°ƒçš„è¿”å›å€¼ï¼›
- å›è°ƒå‡½æ•°çš„å‚æ•°æ˜¯ï¼š**åŸå§‹çš„ `future<T>` å¯¹è±¡**ï¼›
- å›è°ƒå‡½æ•°å¯ä»¥é€šè¿‡ `.get()` æ‹¿åˆ°å®é™…å€¼ï¼Œæˆ–å¤„ç†å¼‚å¸¸ã€‚

#### ç¤ºä¾‹ï¼šæŒç»­æ€§å‡½æ•°ç­¾å

```cpp
std::string find_the_question(std::experimental::future<int> the_answer);
```

å¦‚æœ `find_the_answer()` è¿”å› `int`ï¼Œé‚£ä¹ˆ `then()` ä¸­çš„å‡½æ•°å°±åº”æ¥å—ä¸€ä¸ª `future<int>`ï¼Œä»¥ä¾¿æ˜¾å¼å¤„ç†å€¼æˆ–å¼‚å¸¸ã€‚

#### ä¸ºä»€ä¹ˆä¼ å…¥ `future<T>` è€Œä¸æ˜¯å€¼ `T`ï¼Ÿ

è¿™æ ·å¯ä»¥è®© **å›è°ƒå‡½æ•°è‡ªå·±å†³å®šå¦‚ä½•å¤„ç†å¼‚å¸¸**ï¼Œè€Œä¸æ˜¯ç”±è¿è¡Œåº“è‡ªåŠ¨æŠ›å‡ºã€‚

ç¤ºä¾‹ï¼š

```cpp
std::string find_the_question(std::experimental::future<int> the_answer) {
    try {
        int value = the_answer.get();  // æ˜¾å¼è·å–å€¼
        return "The question to " + std::to_string(value) + " is ...";
    } catch (const std::exception& e) {
        return "Failed to get the answer: " + std::string(e.what());
    }
}
```

#### è‡ªå®šä¹‰ async å®ç°ï¼ˆç­‰ä»·äº `std::async`ï¼‰

ä½¿ç”¨ `std::experimental::promise` å®ç°ä¸€ä¸ªç®€æ˜“çš„å¼‚æ­¥ä»»åŠ¡åˆ†å‘å‡½æ•°ã€‚

```cpp
template<typename Func>
std::experimental::future<decltype(std::declval<Func>()())>
spawn_async(Func&& func) {
  std::experimental::promise<decltype(std::declval<Func>()())> p;

  // è·å–å¯¹åº” future
  auto res = p.get_future();

  // å¯åŠ¨çº¿ç¨‹æ‰§è¡Œä»»åŠ¡
  std::thread t(
    [p = std::move(p), f = std::decay_t<Func>(func)]() mutable {
      try {
        // è®¾ç½®å€¼ï¼ˆçº¿ç¨‹é€€å‡ºæ—¶æ‰ä¼ é€’ï¼Œç¡®ä¿ thread_local æ¸…ç†å®Œï¼‰
        p.set_value_at_thread_exit(f());
      } catch (...) {
        // å¦‚æœå¼‚å¸¸ï¼Œæ•è·å¹¶å­˜å…¥ future
        p.set_exception_at_thread_exit(std::current_exception());
      }
    });

  t.detach();  // åˆ†ç¦»çº¿ç¨‹
  return res;
}
```

| è¡Œä¸º                           | å®ç°æ–¹å¼                             |
| ------------------------------ | ------------------------------------ |
| è¿”å› future                    | `promise::get_future()`              |
| åœ¨çº¿ç¨‹ä¸­æ‰§è¡Œå‡½æ•°               | `std::thread` + `detach()`           |
| æ•è·å¼‚å¸¸å¹¶ä¼ é€’åˆ° future        | `set_exception_at_thread_exit()`     |
| åœ¨ future ä¸­è®¾ç½®è¿”å›å€¼         | `set_value_at_thread_exit()`         |
| æ”¯æŒé“¾å¼ then() æ³¨å†ŒæŒç»­æ€§æ“ä½œ | `std::experimental::future` æä¾›æ”¯æŒ |

#### æŒç»­æ€§é“¾å¼è°ƒç”¨ï¼ˆå¯ç»„åˆï¼‰

ç”±äº `then()` è¿”å›çš„æ˜¯æ–°çš„ `future`ï¼Œæˆ‘ä»¬å¯ä»¥è¿›è¡Œ **é“¾å¼ç»„åˆ**ï¼š

```cpp
auto fut = spawn_async([] { return 42; })
             .then([](auto fut) {
                 return fut.get() + 1;
             })
             .then([](auto fut) {
                 std::cout << "Answer is: " << fut.get() << std::endl;
             });
```

#### å°ç»“

| ç‰¹æ€§                 | `std::experimental::future` æä¾›çš„èƒ½åŠ›        |
| -------------------- | --------------------------------------------- |
| å¼‚æ­¥ç»“æœè‡ªåŠ¨å¤„ç†     | ä½¿ç”¨ `then()` æ·»åŠ å¤„ç†é€»è¾‘                    |
| æ”¯æŒé“¾å¼ç»„åˆ         | æ¯ä¸ª `then()` è¿”å›æ–°çš„ futureï¼Œå¯æŒç»­ç»„åˆ     |
| æ˜¾å¼å¤„ç†å¼‚å¸¸         | å›è°ƒå‡½æ•°æ”¶åˆ°çš„æ˜¯ `future<T>`ï¼Œå¯è°ƒç”¨ `.get()` |
| çµæ´»çš„çº¿ç¨‹è°ƒåº¦ç­–ç•¥   | `then()` ä¸å¼ºåˆ¶åœ¨å“ªä¸ªçº¿ç¨‹æ‰§è¡Œï¼Œç”±åº“å®ç°å†³å®š   |
| å…¼å®¹ std::async è¡Œä¸º | å¯è‡ªå®šä¹‰å°è£…æˆç±»ä¼¼ `async` çš„å‡½æ•°             |

### æŒç»­æ€§è¿æ¥

ä½¿ç”¨ `std::experimental::future` å®ç°å¤šæ­¥éª¤å¼‚æ­¥ä»»åŠ¡çš„é“¾å¼æ‰§è¡Œä¸è‡ªåŠ¨è§¦å‘

#### ä½¿ç”¨åœºæ™¯ä¸¾ä¾‹

ä¾‹å¦‚ï¼šç”¨æˆ·ç™»å½•åº”ç”¨æ—¶ï¼Œéœ€è¦æŒ‰é¡ºåºå®Œæˆä»¥ä¸‹æ“ä½œï¼š

1. å‘é€ç”¨æˆ·åä¸å¯†ç è¿›è¡Œèº«ä»½éªŒè¯ï¼›
2. éªŒè¯æˆåŠŸåè¯·æ±‚ç”¨æˆ·æ•°æ®ï¼›
3. æ›´æ–° UI å±•ç¤ºç”¨æˆ·æ•°æ®ã€‚

#### åŒæ­¥æ–¹å¼å®ç°

åŒæ­¥å®ç°ï¼ˆé˜»å¡ UIï¼‰ï¼š

```cpp
void process_login(std::string const& username, std::string const& password)
{
  try {
    user_id const id = backend.authenticate_user(username, password);
    user_data const info_to_display = backend.request_current_info(id);
    update_display(info_to_display);
  } catch(std::exception& e) {
    display_error(e);
  }
}
```

ç¼ºç‚¹ï¼šä¼šé˜»å¡è°ƒç”¨çº¿ç¨‹ï¼ˆUIå¡é¡¿ï¼‰ï¼Œä¸èƒ½å¹¶å‘å¤„ç†å¤šä¸ªç”¨æˆ·ç™»å½•ã€‚

#### ç®€å•å¼‚æ­¥å®ç°

ç®€å•å¼‚æ­¥å®ç°ï¼š

```cpp
std::future<void> process_login(
  std::string const& username, std::string const& password)
{
  return std::async(std::launch::async, [=]() {
    try {
      user_id const id = backend.authenticate_user(username, password);
      user_data const info_to_display = backend.request_current_info(id);
      update_display(info_to_display);
    } catch(std::exception& e) {
      display_error(e);
    }
  });
}
```

è¿™è™½æ˜¯å¼‚æ­¥è°ƒç”¨ï¼Œä½† **æ•´ä¸ªé“¾ä»ç„¶åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸­é¡ºåºæ‰§è¡Œ**ï¼Œç¼ºä¹ç²’åº¦æ§åˆ¶ï¼Œä¹Ÿä¸èƒ½è§£è€¦æ­¥éª¤ã€‚

#### æŒç»­æ€§ï¼ˆcontinuationï¼‰å¼‚æ­¥æ–¹å¼

é“¾å¼æŒç»­æ€§å®ç°ï¼š

```cpp
std::experimental::future<void> process_login(
  std::string const& username, std::string const& password)
{
  return spawn_async([=]() {
    return backend.authenticate_user(username, password);
  }).then([](std::experimental::future<user_id> id) {
    return backend.request_current_info(id.get());
  }).then([](std::experimental::future<user_data> info_to_display) {
    try {
      update_display(info_to_display.get());
    } catch(std::exception& e) {
      display_error(e);
    }
  });
}
```

- æ¯ä¸€æ­¥æ‰§è¡Œå®Œæ‰è§¦å‘ä¸‹ä¸€æ­¥ï¼ˆéé˜»å¡é“¾å¼æ‰§è¡Œï¼‰ï¼›
- æ¯ä¸ª `.then()` æ¥æ”¶ `future<T>`ï¼Œé€šè¿‡ `.get()` å–å€¼å¹¶å¤„ç†å¼‚å¸¸ï¼›
- æ¯”åŒæ­¥æ–¹å¼æ›´åŠ **å“åº”å¼**ï¼Œé€‚åˆæ„å»ºå¤æ‚ UI å¼‚æ­¥é€»è¾‘ã€‚

#### å¼•å…¥ async æ¥å£ï¼šå®Œå…¨å¼‚æ­¥æ‰§è¡Œé“¾

ä¸Šä¾‹ä¸­çš„ `backend.authenticate_user()` å’Œ `backend.request_current_info()` ä»æ˜¯åŒæ­¥çš„ã€‚ä¸ºäº†æ›´å½»åº•çš„å¼‚æ­¥åŒ–ï¼š

- ä½¿ç”¨å¼‚æ­¥ç‰ˆæœ¬ï¼š`backend.async_authenticate_user()`ï¼›
- é¿å…é˜»å¡ç­‰å¾…åç«¯å“åº”ã€‚

å…¨å¼‚æ­¥æ“ä½œï¼š

```cpp
std::experimental::future<void> process_login(
  std::string const& username, std::string const& password)
{
  return backend.async_authenticate_user(username, password).then(
    [](std::experimental::future<user_id> id) {
      return backend.async_request_current_info(id.get());
    }).then([](std::experimental::future<user_data> info_to_display) {
      try {
        update_display(info_to_display.get());
      } catch(std::exception& e) {
        display_error(e);
      }
    });
}
```

- æ‰€æœ‰æ“ä½œå¼‚æ­¥è¿›è¡Œï¼Œä¸»çº¿ç¨‹å¯æŒç»­å“åº” UIï¼›
- å› ä½¿ç”¨äº† *future å±•å¼€ï¼ˆfuture-unwrappingï¼‰*ï¼Œé¿å…å‡ºç°åµŒå¥— future ç±»å‹ï¼ˆå¦‚ `future<future<T>>`ï¼‰ï¼›
- å¦‚æœæ”¯æŒ C++14ï¼Œå¯ç”¨æ³›å‹ Lambda ç®€åŒ–ç±»å‹ä¹¦å†™ã€‚

æ³›å‹ Lambda ç¤ºä¾‹ï¼ˆC++14 èµ·ï¼‰

```cpp
return backend.async_authenticate_user(username, password).then(
  [](auto id) {
    return backend.async_request_current_info(id.get());
  });
```

#### å…±äº« future ä¸å¤šæŒç»­æ€§è¿æ¥

æœ‰æ—¶éœ€è¦**å¤šä¸ªå¤„ç†é€»è¾‘å…±äº«åŒä¸€ä¸ªå¼‚æ­¥ç»“æœ**ã€‚è¿™æ—¶å¯ä»¥ä½¿ç”¨ `shared_future`ã€‚

`shared_future` å¤šæŒç»­æ€§ï¼š

```cpp
auto fut = spawn_async(some_function).share();  // è½¬ä¸ºå…±äº« future

auto fut2 = fut.then([](std::experimental::shared_future<some_data> data) {
  do_stuff(data);
});

auto fut3 = fut.then([](std::experimental::shared_future<some_data> data) {
  return do_other_stuff(data);
});
```

| ç‰¹æ€§                         | è¯´æ˜                                   |
| ---------------------------- | -------------------------------------- |
| `.share()`                   | å°† `future<T>` è½¬ä¸º `shared_future<T>` |
| å¤šä¸ª `.then()` å¯å¹¶å‘ä½¿ç”¨    | æ¯ä¸ª then éƒ½ç»‘å®šä¸€ä¸ªå¤„ç†é€»è¾‘           |
| å‚æ•°ç±»å‹éœ€æ˜¯ `shared_future` | é¿å…æ•°æ®ç«äº‰å’Œæ— æ•ˆå¼•ç”¨                 |

æ³¨æ„ï¼šä¸èƒ½å°†ä¸´æ—¶ `shared_future` ä½œä¸ºæŒç»­æ€§å‚æ•°ï¼›è¦å…ˆä¿å­˜å¹¶å¤ç”¨ã€‚

#### æ€»ç»“ï¼šæŒç»­æ€§é“¾å¼ç¼–ç¨‹ä¼˜åŠ¿

| å¯¹æ¯”ç‚¹         | åŒæ­¥æ–¹å¼           | å¼‚æ­¥+future           | æŒç»­æ€§ï¼ˆthenï¼‰æ–¹å¼             |
| -------------- | ------------------ | --------------------- | ------------------------------ |
| æ˜¯å¦é˜»å¡çº¿ç¨‹   | æ˜¯                 | å¦ï¼ˆå–å†³äº get è°ƒç”¨ï¼‰ | å¦ï¼ŒçœŸæ­£éé˜»å¡                 |
| ä»»åŠ¡æ˜¯å¦ä¸²è¡Œ   | æ˜¯                 | æ˜¯                    | å¯åˆ†æ®µå¹¶è¡Œï¼ŒæŒ‰éœ€è§¦å‘           |
| æ§åˆ¶æµæ¸…æ™°åº¦   | é«˜                 | ä¸­                    | é«˜ï¼ˆé€»è¾‘æ¸…æ™°ã€æ— å…±äº«çŠ¶æ€ï¼‰     |
| å¼‚å¸¸å¤„ç†       | try/catch åŒ…è£¹æ•´æ®µ | éœ€ç»Ÿä¸€å¤„ç†            | æ¯æ®µç‹¬ç«‹å¤„ç†                   |
| æ”¯æŒå¤šä¸ªæ¶ˆè´¹è€… | å¦                 | å¦                    | `shared_future` æ”¯æŒ           |
| çº¿ç¨‹å¤ç”¨èƒ½åŠ›   | å·®                 | ä¸€èˆ¬                  | æ˜“ä¸çº¿ç¨‹æ± æ•´åˆï¼Œçº¿ç¨‹åˆ©ç”¨ç‡æ›´é«˜ |

### ç­‰å¾…å¤šä¸ª `future`

åœ¨å¹¶å‘ä»»åŠ¡ä¸­ï¼Œå¸¸è§çš„éœ€æ±‚æ˜¯ï¼š**å¤šä¸ªä»»åŠ¡å¹¶è¡Œå¤„ç†ï¼Œæ¯ä¸ªä»»åŠ¡è¿”å›ä¸€ä¸ª `future`ï¼Œç­‰æ‰€æœ‰ä»»åŠ¡å®Œæˆåå†åšç»Ÿä¸€å¤„ç†**ã€‚ä¸ºäº†æœ‰æ•ˆç®¡ç†è¿™äº›å¼‚æ­¥ä»»åŠ¡çš„ç”Ÿå‘½å‘¨æœŸï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ ‡å‡†åº“æˆ–æ‰©å±•åº“æä¾›çš„å·¥å…·ã€‚

#### é—®é¢˜å¼•å…¥ï¼šå¦‚ä½•ç­‰å¾…å¤šä¸ªå¼‚æ­¥ä»»åŠ¡å®Œæˆï¼Ÿ

å‡è®¾æœ‰ä¸€ç»„æ•°æ® `vec`ï¼Œæˆ‘ä»¬å¸Œæœ›å¯¹å…¶è¿›è¡Œåˆ†ç‰‡å¤„ç†ï¼Œæ¯ç‰‡æ•°æ®ç”±ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡å¤„ç†ï¼Œæœ€åæ”¶é›†æ‰€æœ‰ç»“æœå¹¶æ±‡æ€»ä¸ºä¸€ä¸ª `FinalResult`ã€‚

#### ä½¿ç”¨ `std::async` + `future.get()`

ä¼ ç»Ÿå¼‚æ­¥å¤„ç†æ–¹å¼ï¼š

```cpp
std::future<FinalResult> process_data(std::vector<MyData>& vec)
{
  size_t const chunk_size = whatever;
  std::vector<std::future<ChunkResult>> results;

  for (auto begin = vec.begin(), end = vec.end(); begin != end;) {
    size_t const remaining_size = end - begin;
    size_t const this_chunk_size = std::min(remaining_size, chunk_size);

    results.push_back(
      std::async(process_chunk, begin, begin + this_chunk_size)
    );

    begin += this_chunk_size;
  }

  return std::async([all_results = std::move(results)]() {
    std::vector<ChunkResult> v;
    v.reserve(all_results.size());

    for (auto& f : all_results) {
      v.push_back(f.get()); // â‘  é˜»å¡å¼è·å–ç»“æœ
    }

    return gather_results(v);
  });
}
```

- æ‰€æœ‰å¼‚æ­¥ä»»åŠ¡å®Œæˆå‰ï¼Œæœ€åé‚£ä¸€ä¸ª `std::async` åŒ…è£…çš„ä»»åŠ¡ä¼š**é˜»å¡ç­‰å¾…å¤šä¸ª `future.get()`**ã€‚
- è‹¥æœ‰ä»»åŠ¡å°šæœªå®Œæˆï¼Œçº¿ç¨‹ä¼šåå¤å”¤é†’æ£€æŸ¥ï¼Œå°±ç»ªå‰å¯èƒ½åå¤ä¼‘çœ å’Œåˆ‡æ¢ï¼Œ**èµ„æºæµªè´¹ä¸”è°ƒåº¦å¼€é”€å¤§**ã€‚

#### æ”¹è¿›æ–¹æ¡ˆï¼šä½¿ç”¨ `std::experimental::when_all`

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æŠ€æœ¯è§„èŒƒä¸­çš„ `std::experimental::when_all()` å‡½æ•°ï¼Œå®ƒèƒ½ï¼š

- æ¥æ”¶ä¸€ç»„ `future`ï¼›
- è¿”å›ä¸€ä¸ªæ–° `future`ï¼Œå…¶çŠ¶æ€åœ¨**æ‰€æœ‰è¾“å…¥ `future` å°±ç»ªåå˜ä¸ºå°±ç»ª**ï¼›
- é…åˆ `.then()` å®ç°å¼‚æ­¥æ— é˜»å¡é“¾å¼å¤„ç†ã€‚

ä½¿ç”¨ `when_all` å®ç°ï¼š

```cpp
std::experimental::future<FinalResult> process_data(
  std::vector<MyData>& vec)
{
  size_t const chunk_size = whatever;
  std::vector<std::experimental::future<ChunkResult>> results;

  for (auto begin = vec.begin(), end = vec.end(); begin != end;) {
    size_t const remaining_size = end - begin;
    size_t const this_chunk_size = std::min(remaining_size, chunk_size);

    results.push_back(
      spawn_async(process_chunk, begin, begin + this_chunk_size)
    );

    begin += this_chunk_size;
  }

  return std::experimental::when_all(
    results.begin(), results.end()
  ).then( // â‘  å½“æ‰€æœ‰ç»“æœéƒ½å°±ç»ªæ—¶ï¼Œè§¦å‘ Lambda
    [](std::future<std::vector<std::experimental::future<ChunkResult>>> ready_results) {
      std::vector<std::experimental::future<ChunkResult>> all_results = ready_results.get();

      std::vector<ChunkResult> v;
      v.reserve(all_results.size());

      for (auto& f : all_results) {
        v.push_back(f.get()); // â‘¡ å®‰å…¨è·å–æ‰€æœ‰å¤„ç†ç»“æœï¼ˆæ— é˜»å¡ï¼‰
      }

      return gather_results(v);
    }
  );
}
```

| é¡¹ç›®       | `std::async` æ–¹å¼     | `when_all` æ–¹å¼              |
| ---------- | --------------------- | ---------------------------- |
| é˜»å¡ç­‰å¾…   | æ˜¯                    | å¦ï¼Œçº¯å¼‚æ­¥                   |
| èµ„æºæ¶ˆè€—   | é«˜ï¼ˆçº¿ç¨‹å”¤é†’ + ç­‰å¾…ï¼‰ | ä½ï¼ˆç­‰å¾…å°±ç»ªåä¸€æ¬¡æ€§è§¦å‘ï¼‰   |
| æ‰©å±•æ€§     | å·®                    | å¥½ï¼ˆæ”¯æŒå¤§è§„æ¨¡ä»»åŠ¡å¹¶å‘å¤„ç†ï¼‰ |
| ç¼–ç å¤æ‚åº¦ | ä¸­                    | ç¨é«˜ï¼ˆä½†é€»è¾‘æ›´æ¸…æ™°ï¼‰         |

#### è¡¥å……ï¼š`when_any` â€”â€” ç­‰ç¬¬ä¸€ä¸ªä»»åŠ¡å®Œæˆå°±è§¦å‘

å¦‚æœåªå…³å¿ƒ**ä»»æ„ä¸€ä¸ªä»»åŠ¡çš„å®Œæˆ**ï¼Œå¯ä»¥ä½¿ç”¨ `std::experimental::when_any`ï¼š

```cpp
std::experimental::when_any(futures.begin(), futures.end())
  .then([](auto ready_future_group){
    // åªæœ‰ä¸€ä¸ªä»»åŠ¡å®Œæˆï¼Œä¹Ÿä¼šç«‹å³è§¦å‘
    // ä½ å¯ä»¥ä» ready_future_group è·å–å·²å®Œæˆä»»åŠ¡çš„ç´¢å¼•æˆ–å€¼
  });
```

- å¤šä»»åŠ¡æŠ¢å æ‰§è¡Œï¼Œè°å…ˆå®Œæˆå°±å…ˆå“åº”ï¼›
- è¶…æ—¶ä»»åŠ¡ç«é€Ÿï¼Œä¾‹å¦‚ä»å¤šä¸ªå¤‡ä»½æœåŠ¡å™¨å–æœ€å¿«ç»“æœã€‚

#### å°ç»“

| æ–¹æ¡ˆ                          | æè¿°                                       |
| ----------------------------- | ------------------------------------------ |
| `std::async` + `future.get()` | ç®€å•æ˜“ç”¨ï¼Œä½†åœ¨ä»»åŠ¡å¤šæ—¶æ•ˆç‡ä½ä¸‹ï¼Œä¼šé˜»å¡çº¿ç¨‹ |
| `when_all`                    | ç­‰æ‰€æœ‰ä»»åŠ¡å®Œæˆåé›†ä¸­å¤„ç†ï¼Œé€‚åˆå…¨å¹¶å‘åœºæ™¯   |
| `when_any`                    | å“åº”æœ€å¿«å®Œæˆçš„ä»»åŠ¡ï¼Œé€‚åˆç«äº‰å¼å¼‚æ­¥å¤„ç†     |
| æŒç»­æ€§ï¼ˆ`.then()`ï¼‰           | å¼‚æ­¥ä»»åŠ¡é“¾å¼å¤„ç†ï¼Œé¿å…é˜»å¡ï¼Œæé«˜çº¿ç¨‹åˆ©ç”¨ç‡ |

### ä½¿ç”¨ `when_any` ç­‰å¾…ç¬¬ä¸€ä¸ª `future`

åœ¨å¤„ç†å¹¶è¡Œæœç´¢ä»»åŠ¡æ—¶ï¼Œå¦‚æœæˆ‘ä»¬åªéœ€è¦**æ‰¾åˆ°ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„ç»“æœ**ï¼Œé‚£ä¹ˆæ²¡å¿…è¦ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆã€‚è¿™æ—¶å€™å°±å¯ä»¥ç”¨ `std::experimental::when_any` æ¥æå‡æ•ˆç‡ã€‚

#### å…¸å‹åœºæ™¯

å‡è®¾ä½ æœ‰ä¸€å¤§å †æ•°æ® `data`ï¼Œç›®æ ‡æ˜¯æ‰¾å‡ºä¸€ä¸ªæ»¡è¶³æŸç§æ¡ä»¶çš„å…ƒç´ ï¼š

- æ»¡è¶³æ¡ä»¶çš„å…ƒç´ å¯èƒ½æœ‰å¤šä¸ªï¼›
- æ‰¾åˆ°ä¸€ä¸ªå³å¯ï¼›
- æ‰¾åˆ°ååœæ­¢å…¶ä»–ä»»åŠ¡çš„æ‰§è¡Œã€‚

#### é—®é¢˜å»ºæ¨¡ï¼šå¹¶è¡Œæœç´¢ + é¦–ä¸ªå‘½ä¸­å³å¤„ç†

ä¸ºäº†é«˜æ•ˆæ‰§è¡Œï¼Œå¯ä»¥ï¼š

1. åˆ©ç”¨ç¡¬ä»¶å¹¶å‘èƒ½åŠ›å°†æ•°æ®æ‹†åˆ†ï¼›
2. å¤šä¸ªå¼‚æ­¥ä»»åŠ¡å¹¶è¡Œæœç´¢ï¼›
3. åˆ©ç”¨ `when_any` ç­‰å¾…**ç¬¬ä¸€ä¸ªå®Œæˆæœç´¢ä»»åŠ¡**çš„ç»“æœï¼›
4. æ‰¾åˆ°å³å¤„ç†ï¼Œæœªæ‰¾åˆ°åˆ™ç»§ç»­ç›‘å¬ä¸‹ä¸€ä¸ªå®Œæˆçš„ä»»åŠ¡ã€‚

#### ç¤ºä¾‹ä»£ç è§£æ

ä½¿ç”¨ `when_any` æŸ¥æ‰¾ç¬¦åˆæ¡ä»¶çš„å€¼ï¼š

```cpp
std::experimental::future<FinalResult>
find_and_process_value(std::vector<MyData> &data)
{
  // 1. æ ¹æ®ç¡¬ä»¶å¹¶å‘èƒ½åŠ›åˆ†é…ä»»åŠ¡æ•°é‡
  unsigned const concurrency = std::thread::hardware_concurrency();
  unsigned const num_tasks = (concurrency > 0) ? concurrency : 2;

  std::vector<std::experimental::future<MyData*>> results;

  // 2. å°†æ•°æ®å‡åŒ€åˆ†æˆ num_tasks ä»½
  auto const chunk_size = (data.size() + num_tasks - 1) / num_tasks;
  auto chunk_begin = data.begin();

  // 3. ç”¨å…±äº« flag æ§åˆ¶å…¶ä»–çº¿ç¨‹æ˜¯å¦ä¸­æ­¢æœç´¢
  std::shared_ptr<std::atomic<bool>> done_flag =
    std::make_shared<std::atomic<bool>>(false);

  // 4. å¯åŠ¨æ¯ä¸ªå¼‚æ­¥ä»»åŠ¡
  for (unsigned i = 0; i < num_tasks; ++i)
  {
    auto chunk_end = (i < (num_tasks - 1)) ? chunk_begin + chunk_size : data.end();
    results.push_back(spawn_async([=] {
      for (auto entry = chunk_begin; !*done_flag && (entry != chunk_end); ++entry)
      {
        if (matches_find_criteria(*entry))  // åŒ¹é…æˆåŠŸ
        {
          *done_flag = true;                // é€šçŸ¥å…¶ä»–çº¿ç¨‹ç»ˆæ­¢æœç´¢
          return &*entry;
        }
      }
      return (MyData*)nullptr;              // æœªæ‰¾åˆ°
    }));
    chunk_begin = chunk_end;
  }

  // 5. æœ€ç»ˆç»“æœ promise
  auto final_result =
    std::make_shared<std::experimental::promise<FinalResult>>();

  // 6. å®šä¹‰æŒç»­æ€§æ“ä½œå™¨
  struct DoneCheck {
    std::shared_ptr<std::experimental::promise<FinalResult>> final_result;

    DoneCheck(std::shared_ptr<std::experimental::promise<FinalResult>> fr)
      : final_result(std::move(fr)) {}

    void operator()(std::experimental::future<
                      std::experimental::when_any_result<
                        std::vector<std::experimental::future<MyData*>>>> results_param)
    {
      auto results = results_param.get();  // è·å– when_any çš„ç»“æœ
      MyData* const ready_result = results.futures[results.index].get();  // è·å–å°±ç»ª future çš„å€¼

      if (ready_result)
      {
        // 6.1 æ‰¾åˆ°äº†ç¬¦åˆæ¡ä»¶çš„æ•°æ®
        final_result->set_value(process_found_value(*ready_result));
      }
      else
      {
        // 6.2 æœªæ‰¾åˆ°ï¼Œç§»é™¤å½“å‰å·²å®Œæˆçš„ä»»åŠ¡
        results.futures.erase(results.futures.begin() + results.index);
        if (!results.futures.empty())
        {
          // 6.3 ç»§ç»­ç›‘å¬ä¸‹ä¸€ä¸ªå®Œæˆä»»åŠ¡
          std::experimental::when_any(
            results.futures.begin(), results.futures.end()
          ).then(std::move(*this));
        }
        else
        {
          // 6.4 æ‰€æœ‰ä»»åŠ¡éƒ½å¤±è´¥ï¼Œè®¾ç½®å¼‚å¸¸
          final_result->set_exception(std::make_exception_ptr(
            std::runtime_error("Not found")));
        }
      }
    }
  };

  // 7. æŒç»­æ€§è¿æ¥
  std::experimental::when_any(results.begin(), results.end())
    .then(DoneCheck(final_result));

  // 8. è¿”å›æœ€ç»ˆ future
  return final_result->get_future();
}
```

#### å®ç°æ€è·¯æ€»ç»“

| æ­¥éª¤       | è¯´æ˜                                        |
| ---------- | ------------------------------------------- |
| æ•°æ®åˆ†ç‰‡   | å¹³å‡åˆ†é…ç»™æ¯ä¸ªä»»åŠ¡ï¼Œæé«˜å¹¶è¡Œæ•ˆç‡            |
| å¼‚æ­¥æ‰§è¡Œ   | ä½¿ç”¨ `spawn_async` å¯åŠ¨ä»»åŠ¡ï¼Œé¿å…ä¸»çº¿ç¨‹é˜»å¡ |
| å¹¶å‘æ§åˆ¶   | `done_flag` æ§åˆ¶å¤šä¸ªçº¿ç¨‹ä¹‹é—´çš„ç»ˆæ­¢æ¡ä»¶      |
| éé˜»å¡ç›‘å¬ | ä½¿ç”¨ `when_any` ç­‰å¾…ç¬¬ä¸€ä¸ªä»»åŠ¡å®Œæˆå¹¶å¤„ç†    |
| å¼‚å¸¸å¤„ç†   | æ²¡æœ‰ä»»ä½•ç»“æœæ—¶ä¸»åŠ¨è®¾ç½®å¼‚å¸¸åˆ° promise        |

#### è¡¥å……ï¼šä½¿ç”¨ `when_all` / `when_any` çš„å˜ä½“å½¢å¼

é™¤äº†ä½¿ç”¨**è¿­ä»£å™¨èŒƒå›´**ï¼Œ`when_all` å’Œ `when_any` ä¹Ÿå¯ä»¥æ¥å—ä¸€ç»„ `future` ä½œä¸º**å˜å‚**ç›´æ¥ä¼ å…¥ï¼š

```cpp
std::experimental::future<int> f1 = spawn_async(func1);
std::experimental::future<std::string> f2 = spawn_async(func2);
std::experimental::future<double> f3 = spawn_async(func3);

auto result = std::experimental::when_all(
  std::move(f1), std::move(f2), std::move(f3)
);

// result ç±»å‹ä¸º future<tuple<future<int>, future<string>, future<double>>>
```

- `future` æ˜¯å•æ¬¡è·å–ç»“æœçš„ï¼Œæ‰€ä»¥å¿…é¡» `std::move`ï¼›
- å¦‚æœè¦å¤šæ¬¡è®¿é—®ï¼Œéœ€è¦ä½¿ç”¨ `shared_future`ï¼›
- å¤šä¸ªè¿”å›å€¼å°è£…åœ¨ `std::tuple` ä¸­ã€‚

#### ä¸è¦æ»¥ç”¨ `future`

æœ‰æ—¶ï¼Œä½ åªæ˜¯æƒ³ç­‰å¾…æŸç»„çº¿ç¨‹ã€æ•°æ®é‡æˆ–æ“ä½œå®Œæˆï¼Œä¸éœ€è¦å…·ä½“è¿”å›å€¼ã€‚è¿™ç§æƒ…å†µå¯ä»¥è€ƒè™‘ï¼š

- `std::latch`ï¼ˆä¸€æ¬¡æ€§å±éšœï¼‰ï¼›
- `std::barrier`ï¼ˆå¯é‡ç”¨å±éšœï¼‰ï¼›
- è‡ªå®šä¹‰è®¡æ•°å™¨ + æ¡ä»¶å˜é‡æ§åˆ¶åŒæ­¥ã€‚

#### å°ç»“

| ç”¨æ³•                         | è¯´æ˜                                             |
| ---------------------------- | ------------------------------------------------ |
| `when_all`                   | æ‰€æœ‰ `future` å®Œæˆæ—¶è¿”å›ç»“æœï¼ˆé€‚ç”¨äºä»»åŠ¡åˆå¹¶ï¼‰   |
| `when_any`                   | ä»»æ„ä¸€ä¸ª `future` å®Œæˆå³è¿”å›ï¼ˆé€‚ç”¨äºâ€œæŠ¢è·‘â€åœºæ™¯ï¼‰ |
| æŒç»­æ€§ `.then()`             | é“¾å¼æ“ä½œï¼Œé¿å…é˜»å¡ç­‰å¾…ï¼Œæé«˜å¼‚æ­¥ç¼–ç¨‹å¯è¯»æ€§       |
| æ”¯æŒå˜å‚ç‰ˆæœ¬                 | å¯æ¥å—å¤šä¸ªä¸åŒç±»å‹çš„ `future`ï¼Œå°è£…æˆ `tuple`    |
| å¤šæ¬¡ä½¿ç”¨éœ€ç”¨ `shared_future` | å¦åˆ™ä½¿ç”¨å `future` ä¼šå¤±æ•ˆ                       |

### é”å­˜å™¨å’Œæ …æ ï¼ˆLatch & Barrierï¼‰

åœ¨å¹¶å‘ç¼–ç¨‹ä¸­ï¼Œé™¤äº† `future`ã€`mutex`ã€`condition_variable` ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸¤ç§å®ç”¨çš„åŒæ­¥æœºåˆ¶ï¼š

- `Latchï¼ˆé”å­˜å™¨ï¼‰`ï¼šä¸€æ¬¡æ€§ã€å•å‘è®¡æ•°ï¼›
- `Barrierï¼ˆæ …æ ï¼‰`ï¼šå¯é‡å¤ä½¿ç”¨çš„çº¿ç¨‹åŒæ­¥æœºåˆ¶ã€‚

#### é”å­˜å™¨ `std::experimental::latch`

##### æ¦‚å¿µè¯´æ˜

- æ˜¯ä¸€ç§**è®¡æ•°åŒæ­¥å·¥å…·**ï¼›
- åˆå§‹åŒ–ä¸€ä¸ªè®¡æ•°å€¼ï¼Œä½¿ç”¨ `count_down()` å‡å°‘è®¡æ•°ï¼›
- ä»»ä½•è°ƒç”¨ `wait()` çš„çº¿ç¨‹éƒ½ä¼šé˜»å¡ï¼Œç›´åˆ°è®¡æ•°å‡ä¸º 0ï¼›
- ä¸€æ—¦å°±ç»ªï¼ˆå‡ä¸º 0ï¼‰ï¼Œ**æ°¸ä¹…ä¿æŒå°±ç»ªæ€**ï¼Œä¸å†é˜»å¡ä»»ä½•è°ƒç”¨ `wait()` çš„çº¿ç¨‹ï¼›
- `latch` æ˜¯**ä¸€æ¬¡æ€§ä½¿ç”¨çš„**ï¼Œä¸èƒ½é‡ç½®ã€‚

##### é€‚ç”¨åœºæ™¯

- ç­‰å¾…å¤šä¸ªå¼‚æ­¥ä»»åŠ¡å…¨éƒ¨å®Œæˆï¼›
- æ§åˆ¶å¤šä¸ªçº¿ç¨‹åœ¨ä¸€ä¸ªæ—¶é—´ç‚¹å¼€å§‹ä»»åŠ¡ï¼›
- æ›¿ä»£ç®€åŒ–ç‰ˆçš„ `join`ã€‚

##### ç¤ºä¾‹ä»£ç ï¼šä½¿ç”¨ latch åŒæ­¥å¯åŠ¨

```cpp
#include <experimental/latch>
#include <thread>
#include <iostream>

std::experimental::latch sync_point(3);  // åˆå§‹å€¼ä¸º 3

void worker(int id) {
  std::cout << "Worker " << id << " ready\n";
  sync_point.count_down();              // å½“å‰çº¿ç¨‹æŠ¥å‘Šå°±ç»ª
  sync_point.wait();                    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å°±ç»ª
  std::cout << "Worker " << id << " starts running\n";
}

int main() {
  std::thread t1(worker, 1);
  std::thread t2(worker, 2);
  std::thread t3(worker, 3);
  t1.join(); t2.join(); t3.join();
}
```

è¾“å‡ºç¤ºæ„

```css
Worker 1 ready
Worker 2 ready
Worker 3 ready
Worker 3 starts running
Worker 1 starts running
Worker 2 starts running
```

#### æ …æ  `std::experimental::barrier`

##### æ¦‚å¿µè¯´æ˜

- æ˜¯ä¸€ç§**å¯é‡ç”¨çš„åŒæ­¥æœºåˆ¶**ï¼›
- æ¯ä¸ªçº¿ç¨‹è°ƒç”¨ `arrive_and_wait()` åˆ°è¾¾æ …æ ï¼›
- æ …æ é˜»å¡ç›´åˆ°**æ‰€æœ‰çº¿ç¨‹éƒ½åˆ°è¾¾**ï¼›
- åˆ°è¾¾åæ‰€æœ‰çº¿ç¨‹ç»§ç»­æ‰§è¡Œï¼›
- å¯ä»¥è®¾ç½® **å®Œæˆå‡½æ•°ï¼ˆphase completion functionï¼‰**ï¼Œåœ¨æ¯è½®ç»“æŸæ—¶è‡ªåŠ¨æ‰§è¡Œã€‚

##### é€‚ç”¨åœºæ™¯

- å¤šçº¿ç¨‹åˆ†é˜¶æ®µåŒæ­¥ï¼›
- æ¯ä¸€è½®ç»“æŸåå†ç»Ÿä¸€è¿›å…¥ä¸‹ä¸€è½®ï¼›
- å¤šçº¿ç¨‹å¹¶è¡Œå¤„ç†ï¼Œæ¯è½®ä¹‹é—´ååŒã€‚

##### ç¤ºä¾‹ä»£ç ï¼šä½¿ç”¨ barrier è¿›è¡Œåˆ†é˜¶æ®µåŒæ­¥

```cpp
#include <experimental/barrier>
#include <thread>
#include <iostream>

constexpr int num_threads = 3;

std::experimental::barrier sync_point(num_threads,
  [] { std::cout << "--- All threads synchronized ---\n"; });

void task(int id) {
  for (int round = 1; round <= 3; ++round) {
    std::cout << "Thread " << id << " working in round " << round << "\n";
    std::this_thread::sleep_for(std::chrono::milliseconds(100 * id)); // æ¨¡æ‹Ÿä¸åŒè¿›åº¦
    sync_point.arrive_and_wait();  // æ …æ åŒæ­¥ç‚¹
  }
}

int main() {
  std::thread t1(task, 1);
  std::thread t2(task, 2);
  std::thread t3(task, 3);
  t1.join(); t2.join(); t3.join();
}
```

è¾“å‡ºç¤ºæ„

```css
Thread 1 working in round 1
Thread 2 working in round 1
Thread 3 working in round 1
--- All threads synchronized ---
Thread 1 working in round 2
Thread 2 working in round 2
Thread 3 working in round 2
--- All threads synchronized ---
Thread 1 working in round 3
Thread 2 working in round 3
Thread 3 working in round 3
--- All threads synchronized ---
```

#### `latch` ä¸ `barrier` å¯¹æ¯”æ€»ç»“

| ç‰¹æ€§         | `latch`                   | `barrier`                        |
| ------------ | ------------------------- | -------------------------------- |
| ç”Ÿå‘½å‘¨æœŸ     | ä¸€æ¬¡æ€§                    | å¯é‡ç”¨ï¼ˆå¤šè½®åŒæ­¥ï¼‰               |
| åŒæ­¥è¡Œä¸º     | åˆ°è¾¾ç‚¹é˜»å¡ï¼Œç›´åˆ°è®¡æ•°ä¸º0   | æ‰€æœ‰çº¿ç¨‹åˆ°è¾¾ï¼Œç»Ÿä¸€ç»§ç»­           |
| æ§åˆ¶è¡Œä¸º     | `count_down()` + `wait()` | `arrive_and_wait()`              |
| æ”¯æŒé¢å¤–å›è°ƒ | å¦                        | âœ… æœ‰å®Œæˆå‡½æ•°ï¼ˆphase completionï¼‰ |
| çº¿ç¨‹è®¡æ•°æ–¹å¼ | ä»»æ„çº¿ç¨‹é€’å‡              | æ¯çº¿ç¨‹æ¯è½®åªèƒ½ä¸€æ¬¡               |
| åº”ç”¨åœºæ™¯     | å¯åŠ¨æ§åˆ¶ï¼Œä»»åŠ¡æ”¶é›†        | åˆ†é˜¶æ®µååŒå¹¶è¡Œ                   |

#### å»¶ä¼¸ç”¨é€”ç¤ºä¾‹

##### latch ç”¨äºç­‰å¾…å¤šä¸ªåå°ä»»åŠ¡å®Œæˆ

```cpp
void parallel_task(std::vector<Task> tasks) {
  std::experimental::latch done(tasks.size());
  for (auto& task : tasks) {
    std::thread([&, task]() {
      do_task(task);
      done.count_down();  // ä»»åŠ¡å®Œæˆ
    }).detach();
  }
  done.wait();  // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
}
```

##### barrier ç”¨äºå›¾åƒå¹¶è¡Œå¤„ç†æ¯å¸§

```cpp
std::experimental::barrier sync_point(num_threads);

void process_frame(Frame& frame, int thread_id) {
  for (int round = 0; round < max_rounds; ++round) {
    compute_slice(frame, thread_id, round);
    sync_point.arrive_and_wait();  // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆæœ¬è½®
  }
}
```

### `std::experimental::latch`ï¼šåŸºç¡€çš„é”å­˜å™¨ç±»å‹

#### æ¦‚è¿°

`std::experimental::latch` æ˜¯ C++ æä¾›çš„ä¸€ç§åŸºç¡€çš„åŒæ­¥æœºåˆ¶ï¼Œå£°æ˜äº `<experimental/latch>` å¤´æ–‡ä»¶ã€‚å®ƒé€‚ç”¨äºä¸€ç»„çº¿ç¨‹ä¸­çš„æŸäº›çº¿ç¨‹éœ€è¦ç­‰å¾…å…¶ä»–çº¿ç¨‹å®ŒæˆæŸé¡¹ä»»åŠ¡ä¹‹åæ‰èƒ½ç»§ç»­æ‰§è¡Œçš„åœºæ™¯ã€‚

- åˆå§‹æ—¶è®¾ç½®ä¸€ä¸ªè®¡æ•°å€¼ï¼›
- è°ƒç”¨ `count_down()` ä½¿è®¡æ•°é€’å‡ï¼›
- å½“è®¡æ•°ä¸º 0 æ—¶ï¼Œ`latch` è¿›å…¥**å°±ç»ªæ€**ï¼›
- ç­‰å¾…çº¿ç¨‹é€šè¿‡ `wait()` é˜»å¡ï¼Œç›´åˆ° `latch` å°±ç»ªï¼›
- å¯è°ƒç”¨ `is_ready()` æ£€æŸ¥æ˜¯å¦å°±ç»ªï¼›
- `count_down_and_wait()` è¡¨ç¤º**é€’å‡åç­‰å¾…**ã€‚

> latch æ˜¯**ä¸€æ¬¡æ€§**åŒæ­¥å·¥å…·ï¼Œä¸èƒ½é‡ç½®æˆ–å¤ç”¨ã€‚

####  ç¤ºä¾‹ä»£ç ï¼šç­‰å¾…æ‰€æœ‰çº¿ç¨‹çš„æ•°æ®å‡†å¤‡å®Œæˆ

```cpp
#include <experimental/latch>
#include <vector>
#include <future>

void foo() {
  unsigned const thread_count = ...; // å®é™…çº¿ç¨‹æ•°
  std::experimental::latch done(thread_count);  // â‘  åˆå§‹åŒ– latch
  my_data data[thread_count];
  std::vector<std::future<void>> threads;

  for (unsigned i = 0; i < thread_count; ++i) {
    threads.push_back(std::async(std::launch::async, [&, i] {  // â‘¡ é€šè¿‡å€¼æ•è· iï¼Œå…¶ä»–å¼•ç”¨æ•è·
      data[i] = make_data(i);
      done.count_down();         // â‘¢ æ•°æ®å‡†å¤‡å®Œæ¯•åå‡å°‘ latch è®¡æ•°
      do_more_stuff();           // â‘£ çº¿ç¨‹ç»§ç»­æ‰§è¡Œå…¶ä»–å·¥ä½œ
    }));
  }

  done.wait();                   // â‘¤ ä¸»çº¿ç¨‹ç­‰å¾…æ‰€æœ‰æ•°æ®å‡†å¤‡å®Œæˆ
  process_data(data, thread_count);  // â‘¥ å¯¹æ”¶é›†åˆ°çš„æ•°æ®è¿›è¡Œå¤„ç†
} // â‘¦ ç­‰å¾… future ææ„ï¼Œç¡®ä¿çº¿ç¨‹æ‰§è¡Œå®Œæ¯•
```

#### ç¤ºä¾‹è¯´æ˜

- **â‘  åˆå§‹åŒ– latch**ï¼šè®¾ç½®åˆå§‹è®¡æ•°ä¸ºçº¿ç¨‹æ•°ï¼›
- **â‘¡ æ•è·æ–¹å¼è¯´æ˜**ï¼š
  - `i` ä½¿ç”¨å€¼æ•è·ï¼šé¿å…å¾ªç¯å˜é‡è¢«ä¿®æ”¹å¼•å‘ç«äº‰ï¼›
  - å…¶ä»–å˜é‡ï¼ˆå¦‚ `data`, `done`ï¼‰ä½¿ç”¨å¼•ç”¨æ•è·ï¼›
- **â‘¢ `count_down()`**ï¼šçº¿ç¨‹ä»»åŠ¡å®ŒæˆåæŠ¥å‘Šï¼›
- **â‘£ `do_more_stuff()`**ï¼šçº¿ç¨‹å¯ç»§ç»­æ‰§è¡Œå…¶ä»–éå…³é”®ä»»åŠ¡ï¼›
- **â‘¤ `wait()`**ï¼šä¸»çº¿ç¨‹é˜»å¡ç›´åˆ° latch å‡ä¸º 0ï¼›
- **â‘¥ `process_data`**ï¼šæ•°æ®å‡†å¤‡å®Œæ¯•åå®‰å…¨å¤„ç†ï¼›
- **â‘¦ `future` ææ„**ï¼šç¡®ä¿çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸå®Œæ•´ï¼›

#### latch å¸¦æ¥çš„çº¿ç¨‹å®‰å…¨æ€§

ç”±äº `latch` æ˜¯åŒæ­¥å¯¹è±¡ï¼Œå¤šä¸ªçº¿ç¨‹å¯¹ `count_down()` çš„è°ƒç”¨æ˜¯**å†…å­˜å¯è§çš„**ï¼Œå› æ­¤ä¸»çº¿ç¨‹è°ƒç”¨ `wait()` å¯ä»¥å‡†ç¡®æ£€æµ‹åˆ°çº¿ç¨‹çŠ¶æ€çš„å˜åŒ–ï¼Œé¿å…æ•°æ®ç«äº‰ã€‚

#### ä½¿ç”¨ latch çš„å¸¸è§åœºæ™¯

| åœºæ™¯                         | æè¿°                                            |
| ---------------------------- | ----------------------------------------------- |
| å¤šçº¿ç¨‹å¯åŠ¨å‰åŒæ­¥             | ç­‰æ‰€æœ‰çº¿ç¨‹å‡†å¤‡å®Œæ¯•åå†ç»Ÿä¸€å¼€å§‹æ‰§è¡Œ              |
| å¼‚æ­¥ä»»åŠ¡å‡†å¤‡é˜¶æ®µåŒæ­¥         | æ‰€æœ‰å­ä»»åŠ¡å‡†å¤‡å®Œæ•°æ®åå†è¿›è¡Œä¸»çº¿ç¨‹å¤„ç†          |
| æ›¿ä»£æ‰‹åŠ¨ä½¿ç”¨ `join` ç­‰å¾…çº¿ç¨‹ | latch + async/future çš„ç»„åˆæ˜¯ `join` çš„é«˜é˜¶æ›¿ä»£ |

#### æ³¨æ„äº‹é¡¹

- `latch` æ˜¯**ä¸€æ¬¡æ€§å·¥å…·**ï¼Œä½¿ç”¨ä¸€æ¬¡åä¸å¯é‡ç½®ï¼›
- `wait()` åº”åœ¨æ‰€æœ‰ä»»åŠ¡è°ƒç”¨ `count_down()` åè°ƒç”¨ï¼›
- è‹¥æƒ³å¤ç”¨åŒæ­¥é€»è¾‘ï¼Œè¯·ä½¿ç”¨ `std::experimental::barrier`ï¼›

### `std::experimental::barrier`ï¼šç®€å•çš„æ …æ 

#### æ¦‚è¿°

åœ¨ `<experimental/barrier>` ä¸­ï¼ŒC++ æä¾›äº†ä¸¤ç§æ …æ ï¼ˆbarrierï¼‰ç±»å‹ï¼š

- `std::experimental::barrier`ï¼ˆ**ç®€å•ä¸”é«˜æ•ˆ**ï¼‰âœ…
- `std::experimental::flex_barrier`ï¼ˆ**æ›´çµæ´»ä½†ä»£ä»·æ›´é«˜**ï¼‰ğŸ”§

ä¸¤è€…éƒ½èƒ½ç”¨äºä¸€ç»„çº¿ç¨‹çš„**é˜¶æ®µæ€§åŒæ­¥**ã€‚é€‚ç”¨äºä»¥ä¸‹åœºæ™¯ï¼š

> **â€œæ‰€æœ‰çº¿ç¨‹å¿…é¡»åœ¨æŸä¸ªæ—¶é—´ç‚¹ç­‰å¾…å…¶ä»–çº¿ç¨‹ï¼Œç„¶åä¸€èµ·ç»§ç»­ä¸‹ä¸€é˜¶æ®µã€‚â€**

#### æ …æ çš„ç”¨é€”

è®¾æƒ³ï¼šå¤šçº¿ç¨‹åŒæ—¶å¤„ç†æ•°æ®ï¼Œæ¯ä¸ªçº¿ç¨‹å¤„ç†ä¸åŒçš„éƒ¨åˆ†ï¼Œä½†å¿…é¡»ç­‰æ‰€æœ‰çº¿ç¨‹å¤„ç†å®Œå½“å‰æ‰¹æ¬¡åï¼Œæ‰èƒ½è¿›å…¥ä¸‹ä¸€æ‰¹æ¬¡ã€‚

ä½¿ç”¨ `std::experimental::barrier`ï¼š

- è®¾ç½®çº¿ç¨‹æ•°ï¼›
- æ¯ä¸ªçº¿ç¨‹è°ƒç”¨ `arrive_and_wait()` è¿›å…¥é˜»å¡ï¼›
- æœ€åä¸€ä¸ªåˆ°è¾¾çš„çº¿ç¨‹ä¼šå”¤é†’æ‰€æœ‰çº¿ç¨‹ï¼›
- æ‰€æœ‰çº¿ç¨‹å¯è¿›å…¥ä¸‹ä¸€é˜¶æ®µï¼›
- æ …æ å¯è¢«**å¤ç”¨**ï¼

> ä¸ä¸€æ¬¡æ€§ `latch` ä¸åŒï¼Œ`barrier` å¯ä»¥**å¾ªç¯ä½¿ç”¨**ã€‚

#### ç¤ºä¾‹ä»£ç ï¼šä½¿ç”¨ `barrier` åŒæ­¥å¤„ç†æ•°æ®å—

```cpp
#include <experimental/barrier>
#include <vector>
#include <thread>
#include "joining_thread.h" // è§ 2.7 ç« èŠ‚

result_chunk process(data_chunk);
std::vector<data_chunk> divide_into_chunks(data_block data, unsigned num_threads);

void process_data(data_source& source, data_sink& sink) {
  unsigned const concurrency = std::thread::hardware_concurrency();
  unsigned const num_threads = (concurrency > 0) ? concurrency : 2;

  std::experimental::barrier sync(num_threads); // åˆ›å»º barrier
  std::vector<joining_thread> threads(num_threads);

  std::vector<data_chunk> chunks;
  result_block result;

  for (unsigned i = 0; i < num_threads; ++i) {
    threads[i] = joining_thread([&, i] {
      while (!source.done()) {                       // â‘¥ æ£€æŸ¥æ•°æ®æ˜¯å¦å¤„ç†å®Œ
        if (!i) {                                     // â‘  åªæœ‰ 0 å·çº¿ç¨‹åˆ’åˆ†æ•°æ®å—
          data_block current_block = source.get_next_data_block();
          chunks = divide_into_chunks(current_block, num_threads);
        }
        sync.arrive_and_wait();                       // â‘¡ ç­‰å¾…æ‰€æœ‰çº¿ç¨‹æ•°æ®å‡†å¤‡å®Œæˆ
        result.set_chunk(i, num_threads, process(chunks[i])); // â‘¢ å„çº¿ç¨‹å¤„ç†è‡ªå·±çš„å—
        sync.arrive_and_wait();                       // â‘£ ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆè®¡ç®—
        if (!i) {                                     // â‘¤ 0 å·çº¿ç¨‹ç»Ÿä¸€è¾“å‡º
          sink.write_data(std::move(result));
        }
      }
    });
  }
} // â‘¦ joining_thread ææ„ä¿è¯çº¿ç¨‹å…¨éƒ¨å®Œæˆ
```

#### ç¤ºä¾‹è¯¦è§£

| æ­¥éª¤ | è¯´æ˜                                                      |
| ---- | --------------------------------------------------------- |
| â‘     | **åªæœ‰çº¿ç¨‹ 0** æ‰§è¡Œæ•°æ®åˆ’åˆ†æ“ä½œï¼ˆä¸²è¡Œéƒ¨åˆ†ï¼‰               |
| â‘¡    | æ‰€æœ‰çº¿ç¨‹**åŒæ­¥ç­‰å¾…**ï¼Œç›´åˆ°æ•°æ®å‡†å¤‡å®Œæ¯•                    |
| â‘¢    | æ¯ä¸ªçº¿ç¨‹å¤„ç†è‡ªå·±çš„ `data_chunk`                           |
| â‘£    | æ‰€æœ‰çº¿ç¨‹å†æ¬¡åŒæ­¥ç­‰å¾…ï¼Œç¡®ä¿è®¡ç®—å®Œæˆ                        |
| â‘¤    | ç”±çº¿ç¨‹ 0 è¾“å‡ºå¤„ç†ç»“æœ                                     |
| â‘¥    | çº¿ç¨‹æŒç»­å¾ªç¯ï¼Œå¤„ç†ä¸‹ä¸€æ‰¹æ•°æ®                              |
| â‘¦    | æ‰€æœ‰ `joining_thread` ç¦»å¼€ä½œç”¨åŸŸåè‡ªåŠ¨ joinï¼Œç¡®ä¿çº¿ç¨‹ç»“æŸ |

#### æ …æ çš„å¤ç”¨ä¸é€€å‡º

- `barrier` æ˜¯**å¯å¤ç”¨çš„**ï¼Œæ¯æ¬¡ `arrive_and_wait()` åè‡ªåŠ¨é‡ç½®ï¼›
- è‹¥çº¿ç¨‹è¦é€€å‡º barrierï¼ŒåŒæ­¥ç»„æ•°é‡è¦å‡å°‘ï¼Œå¯è°ƒç”¨ï¼š

```cpp
sync.arrive_and_drop();
```

è¿™æ ·ä¸‹ä¸€ä¸ªå‘¨æœŸå°±ä¼šå‡å°‘ä¸€ä¸ªçº¿ç¨‹çš„ç­‰å¾…æ•°ã€‚

#### æ …æ ä¸çº¿ç¨‹å®‰å…¨

æ …æ æä¾›äº†å¯é çš„åŒæ­¥ç‚¹ï¼Œèƒ½ç¡®ä¿æ‰€æœ‰çº¿ç¨‹**åŒæ­¥è¿›å…¥ä¸‹ä¸€é˜¶æ®µ**ï¼Œé¿å…æ•°æ®ç«äº‰å’Œæœªå®Œæˆçš„ä»»åŠ¡ä¹‹é—´çš„ä¸ä¸€è‡´çŠ¶æ€ã€‚

####  æ …æ ä¸ latch çš„åŒºåˆ«

| ç‰¹æ€§     | `latch`           | `barrier`              |
| -------- | ----------------- | ---------------------- |
| å¯å¤ç”¨   | âŒ å¦ï¼ˆä¸€æ¬¡æ€§ï¼‰    | âœ… æ˜¯                   |
| è§£é”æ–¹å¼ | è®¡æ•°å‡ä¸º 0 åå°±ç»ª | æ‰€æœ‰çº¿ç¨‹åˆ°è¾¾åç»Ÿä¸€é‡Šæ”¾ |
| åº”ç”¨åœºæ™¯ | çº¿ç¨‹å‡†å¤‡é˜¶æ®µç­‰å¾…  | å¤šé˜¶æ®µå¹¶è¡Œä»»åŠ¡åŒæ­¥     |
| é‡ç½®æœºåˆ¶ | æ—                 | è‡ªåŠ¨é‡ç½®æ¯è½®           |

### `std::experimental::flex_barrier` â€” æ›´çµæ´»å’Œæ›´å‹å¥½çš„æ …æ 

#### ä»‹ç»

`std::experimental::flex_barrier` å’Œ `std::experimental::barrier` ç›¸ä¼¼ï¼Œä½†å¤šäº†ä¸€ä¸ªå¼ºå¤§åŠŸèƒ½ï¼š

- **æ„é€ æ—¶ä¼ å…¥ä¸€ä¸ªå®Œæ•´å‡½æ•°ï¼ˆcallableï¼‰å’Œçº¿ç¨‹æ•°ï¼›**
- å½“æ‰€æœ‰çº¿ç¨‹åˆ°è¾¾æ …æ æ—¶ï¼Œ**ç”±å…¶ä¸­ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œè¯¥å‡½æ•°**ï¼ˆé€šå¸¸æ˜¯çº¿ç¨‹0ï¼‰ï¼›
- è¯¥å‡½æ•°ä¸ä»…æ‰§è¡Œä¸²è¡Œä»£ç ï¼Œè¿˜å¯**åŠ¨æ€ä¿®æ”¹ä¸‹ä¸€è½®å‚ä¸æ …æ åŒæ­¥çš„çº¿ç¨‹æ•°é‡**ã€‚

> è¿™æ„å‘³ç€å¼€å‘è€…å¯ä»¥çµæ´»æ§åˆ¶ä¸‹ä¸€é˜¶æ®µçº¿ç¨‹æ•°ï¼Œæ”¯æŒçº¿ç¨‹æ•°çš„å¢åŠ æˆ–å‡å°‘ã€‚

#### ç¤ºä¾‹ä»£ç 

```cpp
void process_data(data_source &source, data_sink &sink) {
  unsigned const concurrency = std::thread::hardware_concurrency();
  unsigned const num_threads = (concurrency > 0) ? concurrency : 2;

  std::vector<data_chunk> chunks;

  // 1. æ‹†åˆ†æ•°æ®çš„ Lambdaï¼Œåç»­ä¼šç”±æ …æ è°ƒç”¨
  auto split_source = [&] {
    if (!source.done()) {
      data_block current_block = source.get_next_data_block();
      chunks = divide_into_chunks(current_block, num_threads);
    }
  };

  split_source(); // 2. åˆæ¬¡æ‹†åˆ†æ•°æ®

  result_block result;

  // 3. æ„é€  flex_barrierï¼Œä¼ å…¥çº¿ç¨‹æ•°å’Œä¸²è¡Œå‡½æ•°
  std::experimental::flex_barrier sync(num_threads, [&] {
    sink.write_data(std::move(result)); // è¾“å‡ºç»“æœ
    split_source();                     // æ‹†åˆ†ä¸‹ä¸€æ‰¹æ•°æ®
    return -1;                         // -1 è¡¨ç¤ºçº¿ç¨‹æ•°ä¿æŒä¸å˜
  });

  std::vector<joining_thread> threads(num_threads);

  for (unsigned i = 0; i < num_threads; ++i) {
    threads[i] = joining_thread([&, i] {
      while (!source.done()) {          // 6. å¾ªç¯ç›´åˆ°æ•°æ®å¤„ç†å®Œ
        result.set_chunk(i, num_threads, process(chunks[i]));
        sync.arrive_and_wait();         // 7. æ …æ åŒæ­¥ç‚¹
      }
    });
  }
}
```

| æ­¥éª¤ | è¯´æ˜                                                         |
| ---- | ------------------------------------------------------------ |
| â‘     | `split_source`ï¼šæ‹†åˆ†æ•°æ®çš„å‡½æ•°ï¼Œè¢«å°è£…ç»™ `flex_barrier` ä½¿ç”¨ |
| â‘¡    | ç¨‹åºå¯åŠ¨æ—¶å…ˆè°ƒç”¨ä¸€æ¬¡æ‹†åˆ†å‡½æ•°ï¼Œå‡†å¤‡åˆå§‹æ•°æ®                   |
| â‘¢    | æ„é€  `flex_barrier`ï¼ŒæŒ‡å®šçº¿ç¨‹æ•°å’Œä¸€ä¸ªä¸²è¡Œå‡½æ•°ï¼Œè¯¥å‡½æ•°ç”±çº¿ç¨‹0æ‰§è¡Œ |
| â‘£    | ä¸²è¡Œå‡½æ•°æ‰§è¡Œæ•°æ®è¾“å‡ºå’Œæ‹†åˆ†ï¼Œå¹¶é€šè¿‡è¿”å›å€¼æ§åˆ¶ä¸‹ä¸€è½®å‚ä¸çº¿ç¨‹æ•° |
| â‘¤    | è¿”å› `-1` è¡¨ç¤ºçº¿ç¨‹æ•°ä¿æŒä¸å˜ï¼›è¿”å›å…¶ä»–å€¼åˆ™å¯åŠ¨æ€è°ƒæ•´çº¿ç¨‹æ•°   |
| â‘¥    | æ¯ä¸ªçº¿ç¨‹åœ¨å¾ªç¯å†…å¤„ç†è‡ªå·±çš„æ•°æ®å—ï¼Œç›´åˆ°æ•°æ®æºè€—å°½             |
| â‘¦    | æ¯è½®å¤„ç†å®Œæˆåè°ƒç”¨ `arrive_and_wait()` ç­‰å¾…æ‰€æœ‰çº¿ç¨‹åŒæ­¥      |

#### `flex_barrier` çš„ä¼˜åŠ¿

- å°†**ä¸²è¡Œé€»è¾‘ç»Ÿä¸€æ”¾å…¥æ …æ çš„å®Œæˆé˜¶æ®µ**ï¼›
- æ”¯æŒ**åŠ¨æ€è°ƒæ•´ä¸‹ä¸€é˜¶æ®µçº¿ç¨‹æ•°é‡**ï¼Œé€‚åˆå¤æ‚æµæ°´çº¿ã€åˆ†é˜¶æ®µå¹¶è¡Œä»»åŠ¡ï¼›
- ä»£ç ç»“æ„æ›´ç®€æ´ï¼Œä¸»å¾ªç¯åªéœ€åŒ…å«**å¹¶è¡Œéƒ¨åˆ†ä»£ç **ï¼Œä¸²è¡Œéƒ¨åˆ†è‡ªåŠ¨å¤„ç†ã€‚

#### å…¸å‹åº”ç”¨åœºæ™¯

- æµæ°´çº¿å¤„ç†ï¼šä¸åŒé˜¶æ®µçº¿ç¨‹æ•°ä¸åŒï¼›
- éœ€è¦åœ¨æ¯è½®åŒæ­¥åæ‰§è¡Œä¸²è¡Œæ“ä½œï¼Œä¸”è¯¥æ“ä½œå½±å“ä¸‹ä¸€è½®çº¿ç¨‹æ•°ï¼›
- å¤æ‚å¹¶è¡Œç®—æ³•ä¸­çš„é˜¶æ®µé—´æ§åˆ¶ã€‚

#### å°ç»“

ç›¸æ¯” `std::experimental::barrier`ï¼Œ`flex_barrier` é€šè¿‡å¼•å…¥å®Œæˆé˜¶æ®µå‡½æ•°ï¼Œä½¿å¾—çº¿ç¨‹åŒæ­¥å’Œä¸²è¡Œæ“ä½œæ›´ç´§å¯†ç»“åˆï¼ŒåŒæ—¶èµ‹äºˆäº†åŠ¨æ€æ§åˆ¶çº¿ç¨‹å‚ä¸æ•°é‡çš„èƒ½åŠ›ï¼Œæ˜¯ä¸€ä¸ªæ›´çµæ´»ã€åŠŸèƒ½æ›´å¼ºå¤§çš„æ …æ æœºåˆ¶ã€‚
